<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="重学JavaScript【对象的结构，创建和继承关系】"><meta name="keywords" content="Object"><meta name="author" content="DaoDaoLee"><meta name="copyright" content="DaoDaoLee"><title>DaoDaoLeeのBlog | DaoDaoLeeのBlog</title><link rel="shortcut icon" href="/avatar.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://v1.hitokoto.cn/?encode=js&amp;charset=utf-8&amp;select=.footer_custom_text" defer></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '5.3.0'
} </script><meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="DaoDaoLeeのBlog" type="application/atom+xml">
</head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%90%86%E8%A7%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.</span> <span class="toc-text">理解对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">属性的类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%99%A8%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.2.</span> <span class="toc-text">访问器属性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%B1%9E%E6%80%A7%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text">读取属性的特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.</span> <span class="toc-text">合并对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E7%AD%89%E5%88%A4%E5%AE%9A"><span class="toc-number">1.4.</span> <span class="toc-text">相等判定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">1.6.</span> <span class="toc-text">对象解构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E7%BB%93%E6%9E%84"><span class="toc-number">1.6.1.</span> <span class="toc-text">嵌套结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E5%88%86%E8%A7%A3%E6%9E%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">部分解构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">创建对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text">工厂模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.2.</span> <span class="toc-text">构造函数模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">原型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%9E%8B"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.2.</span> <span class="toc-text">原型的层级关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E7%9A%84%E7%89%B9%E6%AE%8A%E8%AF%AD%E6%B3%95"><span class="toc-number">2.3.3.</span> <span class="toc-text">原型的特殊语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">3.1.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%AA%E8%A3%85"><span class="toc-number">3.2.</span> <span class="toc-text">对象伪装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.1.</span> <span class="toc-text">经典继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.2.</span> <span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">3.2.3.</span> <span class="toc-text">寄生组合继承</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://i.loli.net/2021/01/18/fopmHdOvFYr5Q7h.jpg"></div><div class="author-info__name text-center">DaoDaoLee</div><div class="author-info__description text-center"></div><div class="follow-button"><a target="_blank" rel="noopener" href="https://github.com/daodaolee">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">11</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">3</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://molunerfinn.com">Molunerfinn</a><a class="author-info-links__name text-center" target="_blank" rel="noopener" href="https://piegg.cn">PiEgg</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2021/01/23/OvztMyob9GYxBgn.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">DaoDaoLeeのBlog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/archives">文章</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/project">项目</a><a class="site-page" href="/about">关于</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">重学JavaScript【对象的结构，创建和继承关系】</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2021-02-22</time><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5k</span><span class="post-meta__separator">|</span><span>阅读时长: 18 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>提到对象肯定都不陌生。但是你真的掌握对象么？本篇就来全面性的说下对象的结构，创建和继承关系</p>
<h1 id="理解对象"><a href="#理解对象" class="headerlink" title="理解对象"></a>理解对象</h1><p>一般来说，创建一个对象通常是创建Object实例，然后再给它添加属性和方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">obj.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">obj.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，say方法会显示abc，在最早期的JavaScript开发者就频繁使用这种方式创建新对象，之后，对象字面量变成了主流:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h2><p>属性的类型定义规范中说明，类型是用两个中括号把特性的名称括起来的，比如：[[Enumerable]]。</p>
<p>属性分为两种：<strong>数据属性</strong> 和 <strong>访问器属性</strong></p>
<h3 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h3><p>   数据属性包含了一个保存数据值的位置，数据属性有四个特性来说明这个位置的值：</p>
<ul>
<li><p>[[Configurable]]</p>
<p>表示属性是否可以通过 delete 删除并且重新定义，默认为true</p>
</li>
<li><p>[[Enumerable]]</p>
<p>表示属性是否可以通过for…in循环访问，也就是是否可枚举，默认为true</p>
</li>
<li><p>[[Writable]]</p>
<p>表示属性是否可以被修改，默认为true</p>
</li>
<li><p>[[Value]]</p>
<p>表示属性的值，默认为undefined</p>
<p>举个例子:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面obj的 [[value]] 就是abc，[[Configurable]]、[[Enumerable]]、[[Writable]]都是true，如果想改变这三个属性，就必须使用 <code>Object.defineProperty()</code> 方法，该方法接收三个参数，要改变的对象，属性名称和一个描述符对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;；</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  writable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">obj.name; <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">obj.name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">obj.name;  <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>上面我肯可以看出obj的writable是false，也就是不可以被修改，所以就算赋值了123，它也还是原来的值，如果是严格模式，赋值123就会报错。</p>
<p>再来看：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line">obj.name; <span class="comment">// &quot;abc&quot;</span></span><br><span class="line"><span class="keyword">delete</span> obj.name;</span><br><span class="line">obj.name;  <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>配置了 configurable 为 false 之后，name属性就删不掉了。<strong>此外一个属性被定义为不可配置后，就不能再变回可配置了！</strong>如果再次调用 Object.defineProperty() 来修改任何非 writable 属性就会报错！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">false</span>,</span><br><span class="line">  value: <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的会报错</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  value: <span class="string">&quot;abc&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在调用 Object.defineProperty() 时，configurable、enumerable 和 writable 的值如果不指定，则都默认为 false。多数情况下，可能都不需要 Object.defineProperty()提供的这些强大的设置，但要理解 JavaScript 对象，就要理解这些概念。</p>
</blockquote>
</li>
</ul>
<h3 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h3><p>访问器属性不包含数据值，它包含一个 <strong>getter(获取)</strong> 和 <strong>setter(设置)</strong> 函数，在读取访问器属性时，会调用这两个函数，一个是读取值，一个是设置新值。访问器也有四个特性：</p>
<ul>
<li><p>[[Configurable]]</p>
<p>和数据属性里的一样，表示是否可以通过 delete 来删除并重新定义，默认为true</p>
</li>
<li><p>[[Enumerable]]</p>
<p>和数据属性里的一样，表示属性是否可以通过for…in循环访问，默认为true</p>
</li>
<li><p>[[Get]]</p>
<p>读取属性时调用，默认为 undefined</p>
</li>
<li><p>[[Set]]</p>
<p>设置属性时调用，默认为 undefined</p>
</li>
</ul>
<p>访问器属性是不可以直接定义的，也得用 <code>Object.defineProperty()</code> ：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, name, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">    value: <span class="string">&quot;abc&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">get</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.name</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">set</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">  	<span class="built_in">this</span>.name = <span class="string">&quot;123&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br><span class="line">obj.name = <span class="string">&quot;xyz&quot;</span>;</span><br><span class="line">obj.name; <span class="comment">// xyz</span></span><br></pre></td></tr></table></figure>
<p>那知道了对象里的属性可以设置之后，如何知道当前对象里的这些属性是什么值呢？</p>
<h2 id="读取属性的特性"><a href="#读取属性的特性" class="headerlink" title="读取属性的特性"></a>读取属性的特性</h2><p>可以使用 <code>Object.getOwnPropertyDescriptor()</code> 方法来获取指定属性的值，会返回一个对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// defineProperties 可以定义多个属性</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">  name_: &#123;</span><br><span class="line">    value: <span class="string">&quot;abc&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  age: &#123;</span><br><span class="line">    value: <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  name: &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.name_</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.name_ = newValue</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="keyword">let</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&quot;name_&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;configurable: false, enumerable: false, value: &quot;abc&quot;, writable: false&#125;</span></span><br><span class="line"><span class="keyword">let</span> desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// &#123;configurable: false, enumerable: false, get: f(), set: f(newValue)&#125;</span></span><br></pre></td></tr></table></figure>
<p>在ECMAScript2017新增了一个方法：<code>Object.getOwnPropertyDescriptors()</code>，比上面的方法多一个s，可以获取所有属性的描述，上面的例子会返回：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*&#123;</span></span><br><span class="line"><span class="comment">  name:&#123;</span></span><br><span class="line"><span class="comment">		configurable: false</span></span><br><span class="line"><span class="comment">    enumerable: false</span></span><br><span class="line"><span class="comment">    get: ƒ ()</span></span><br><span class="line"><span class="comment">    set: ƒ (newValue)</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  age: &#123;</span></span><br><span class="line"><span class="comment">    configurable: false</span></span><br><span class="line"><span class="comment">    enumerable: false</span></span><br><span class="line"><span class="comment">    value: 20</span></span><br><span class="line"><span class="comment">    writable: false</span></span><br><span class="line"><span class="comment">  &#125;,</span></span><br><span class="line"><span class="comment">  name_: &#123;</span></span><br><span class="line"><span class="comment">    configurable: false</span></span><br><span class="line"><span class="comment">    enumerable: false</span></span><br><span class="line"><span class="comment">    value: &quot;abc&quot;</span></span><br><span class="line"><span class="comment">    writable: false</span></span><br><span class="line"><span class="comment">	&#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="合并对象"><a href="#合并对象" class="headerlink" title="合并对象"></a>合并对象</h2><p>在ECMAScript6中，添加了 <code>Object.assign()</code> 方法，可以把两个对象合并成一个，它接收一个目标对象和一个或多个源对象作为参数，它的过程如下：</p>
<ol>
<li>将源对象中可枚举和自有属性复制到目标对象中，可枚举就是 Object.propertyIsEnumerable() 返回是true的，自有属性就是 Object.hasOwnProperty() 返回true的。</li>
<li>只复制以字符串和符号为键的属性</li>
<li>对于每个符合条件的属性，会使用源对象上的 [[Get]] 取得值，使用 [[Set]] 设置值</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj1 = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;,</span><br><span class="line">  obj2 = &#123;<span class="attr">b</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  obj3 = &#123;<span class="attr">a</span>: <span class="number">5</span>&#125;,</span><br><span class="line">  dest = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> result = <span class="built_in">Object</span>.assign(dest, obj1, obj2, obj3);</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// &#123;a: 5, b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(dest); <span class="comment">// &#123;a: 5, b: 2&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(result === dest) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>Object.assign 修改了目标对象！而且有多个源对象的情况下并且有相同的键，后面会覆盖前面的！Object.assign 其实就是对每个源对象进行了浅复制！</strong></p>
<h2 id="相等判定"><a href="#相等判定" class="headerlink" title="相等判定"></a>相等判定</h2><p>在ECMAScript6新增了 <code>Object.is()</code> 方法，判断两个值是否为同一个值，如果满足下列条件就相等：</p>
<ul>
<li>都是 undefined</li>
<li>都是 null</li>
<li>都是 true 或者 false</li>
<li>字符串长度、字符和顺序相同</li>
<li>对象同一个引用</li>
<li>都是数字且<ul>
<li>都是 +0</li>
<li>都是 -0</li>
<li>都是 NaN</li>
<li>或都是非零且非NaN，且为同一个值</li>
</ul>
</li>
</ul>
<p>它和 === 的区别是：三等运算符将数字 -0 和 +0 视为相等，而将 Number.NaN 与 NaN 视为不相等。</p>
<p><img src="https://i.imgur.com/pCyqkLc.png"></p>
<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>ECMAScript6为定义和操作对象做了很多优化，以下是常用的三点：</p>
<ol>
<li><p>属性值简写</p>
<p>相同的属性名可以直接使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可计算属性</p>
<p>如果对象里没有定义某个属性，是不可以用中括号操作的，只能先声明再使用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj[name] = <span class="string">&quot;123&quot;</span></span><br></pre></td></tr></table></figure>
<p>有了可计算属性，可以这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [name]: <span class="string">&quot;123&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>甚至塞入一个方法：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKey</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`key是：<span class="subst">$&#123;key&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [getKey(name)]: <span class="string">&quot;123&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>简写方法名</p>
<p>不需要写 function，直接连起来写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以和可计算属性一起使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> key = <span class="string">&quot;name&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [key](name)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2></li>
</ol>
<p>简单说就是可以把对象里的内容单独拿出来使用，如果没有就是undefined，但是可以赋默认值使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  name: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  age: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123;name, age, say, sex=<span class="string">&quot;male&quot;</span>&#125; = obj;</span><br><span class="line">name <span class="comment">// &quot;abc&quot;</span></span><br><span class="line">age <span class="comment">// 20</span></span><br><span class="line">say <span class="comment">// undefined</span></span><br><span class="line">sex <span class="comment">// male</span></span><br></pre></td></tr></table></figure>
<p>也有一些特殊的解构，比如嵌套解构和部分解构。</p>
<h3 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> age: <span class="number">27</span>, </span><br><span class="line"> job: &#123; </span><br><span class="line"> title: <span class="string">&#x27;Software engineer&#x27;</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> personCopy = &#123;&#125;; </span><br><span class="line">(&#123; </span><br><span class="line"> name: personCopy.name, </span><br><span class="line"> age: personCopy.age, </span><br><span class="line"> job: personCopy.job </span><br><span class="line">&#125; = person);</span><br></pre></td></tr></table></figure>
<p>因为一个对象的引用被赋值给 personCopy，所以修改 person.job 对象的属性也会影响 personCopy </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">person.job.title = <span class="string">&#x27;Hacker&#x27;</span> </span><br><span class="line"><span class="built_in">console</span>.log(person); </span><br><span class="line"><span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125; </span></span><br><span class="line"><span class="built_in">console</span>.log(personCopy); </span><br><span class="line"><span class="comment">// &#123; name: &#x27;Matt&#x27;, age: 27, job: &#123; title: &#x27;Hacker&#x27; &#125; &#125;</span></span><br></pre></td></tr></table></figure>
<p>嵌套结构可以读取多层内部的属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> age: <span class="number">27</span>, </span><br><span class="line"> job: &#123; </span><br><span class="line"> title: <span class="string">&#x27;Software engineer&#x27;</span> </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// 声明 title 变量并将 person.job.title 的值赋给它</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">job</span>: &#123; title &#125; &#125; = person; </span><br><span class="line"><span class="built_in">console</span>.log(title); <span class="comment">// Software engineer</span></span><br></pre></td></tr></table></figure>
<h3 id="部分解构"><a href="#部分解构" class="headerlink" title="部分解构"></a>部分解构</h3><p>如果一个解构涉及了多个赋值，开始的赋值成功，后面的赋值出错，那么整个解构会完成一部分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123; </span><br><span class="line"> name: <span class="string">&#x27;Matt&#x27;</span>, </span><br><span class="line"> age: <span class="number">27</span> </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">let</span> personName, personBar, personAge; </span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"> <span class="comment">// person.foo 是 undefined，因此会抛出错误</span></span><br><span class="line"> (&#123;<span class="attr">name</span>: personName, <span class="attr">foo</span>: &#123; <span class="attr">bar</span>: personBar &#125;, <span class="attr">age</span>: personAge&#125; = person); </span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125; </span><br><span class="line"><span class="built_in">console</span>.log(personName, personBar, personAge); </span><br><span class="line"><span class="comment">// Matt, undefined, undefined</span></span><br></pre></td></tr></table></figure>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>从上面的代码可以看出来，对象创建的方式有：<strong>Object构造函数</strong> 和 对象字面量，但是这两个有个很明显的不足：创建具有同样接口的多个对象需要很多重复代码。为了解决这一点，创建对象较好的方式有三种：<strong>工厂模式</strong> 、 <strong>构造函数模式</strong> 和 <strong>原型模式</strong>。</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式属于一种设计模式，体现在很多语言里，在JavaScript中，利用工厂模式创建可以这样：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span>(<span class="params">name, age, sex</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.sex = sex;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = createObj(<span class="string">&quot;abc&quot;</span>, <span class="number">20</span>, <span class="string">&quot;male&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>通过一个工厂函数内部构建，传入需要的值就可以创建出来。</p>
<h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><p>除了原生的构造函数之外，我们可以自定义构造函数，比如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params">name, age, sex</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> CreateObj(<span class="string">&quot;abc&quot;</span>, <span class="number">20</span>, <span class="string">&quot;male&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>从代码可以看出来它和工厂模式的区别：</p>
<ol>
<li>没有显式地创建对象，也就是没有使用 new Object()</li>
<li>对象的属性和方法赋值给了 this</li>
<li>不用return</li>
</ol>
<p>obj1实例是通过 new 操作符创建的，它的内部逻辑大致为：</p>
<ol>
<li>内存中创建一个对象</li>
<li>对象内部的 [[Prototype]] 被赋值为构造函数的 prototype 属性</li>
<li>构造函数内部的 this 指向了新对象</li>
<li>执行构造函数内部代码</li>
<li>如果构造函数返回了非空对象，则返回该对象，否则返回刚创建的新对象</li>
</ol>
<p>可以通过 constructor 来确定obj1的构造函数就是 CreateObj，也可以用 instanceof，instanceof 用来检测构造函数的prototype是否出现在某个实例对象上：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj1.constructor == CreateObj; <span class="comment">//true</span></span><br><span class="line">obj1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">obj1 <span class="keyword">instanceof</span> CreateObj; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>构造函数要注意亮点：</p>
<ol>
<li><p>构造函数本身也是函数，如果不用 new 的话，生成的实例就会指向window，因为默认全局对象就是window。</p>
</li>
<li><p>如果一个构造函数声明了两个实例，那么这两个实例是互不影响的，二者是不同的，就算调用构造函数的内部方法，也是同名不相等。如果两个实例要做相同的事情，就没必要声明两次内部方法，因为每调用一次实例就会调用一次内部方法来构建，所以这种情况可以把内部方法转移到构造函数的外面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.say = say;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// say方法就可以定义在外面，创建的实例就会共享外面的say方法，而内部的say只是一个指向外部say的指针</span></span><br></pre></td></tr></table></figure>
<p>但是这样又会有一个新的问题，如果有很多个方法呢，都要定义在外部么？原型模式就是解决这个问题的。</p>
</li>
</ol>
<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>   先简单来说一下关键点：每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含了实例共享的属性和方法，也就是说 prototype 就是调用构造函数创建出来的对象。好处是在原型对象定义的属性和方法可以被实例共享。这样的话，在上面的构造函数模式里，赋值给实例的值，可以直接赋值到原型行上，上面的代码用原型模式是这样的：</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">CreateObj.prototype.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">CreateObj.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> CreateObj();</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> CreateObj();</span><br><span class="line">obj1.say == obj2.say; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>   为什么obj1和obj2 **共享 **原型上的方法和属性呢？</p>
<h3 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h3><p>   一个函数被创建，它就会创建一个指向原型对象的 <strong>prototype</strong> 属性，而所有原型对象都有一个叫做 <strong>constructor</strong> 的属性，constructor会指回构造函数。</p>
<p>   按照这样的规定，可以得出 CreateObj(构造函数).prototype(原型).constructor(构造器) === CreateObj(构造函数)，构造函数的原型对象就是 CreateObj.prototype。</p>
<p>   <strong>重点来了！</strong></p>
<p>   在自定义构造函数时(CreateObj)，原型对象默认只会获得 constructor 属性，其他所有方法都继承于Object。每次调用构造函数创建一个新的实例，实例的内部 [[prototype]] 就会被赋值为构造函数(CreateObj)的原型对象。实际情况下在对象上暴露的是<code>__proto__</code>。</p>
<p>   我们再来捋一遍原型干了什么事情：</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先有一个构造函数</span></span><br><span class="line"><span class="keyword">let</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateObj被创建之后，它就有了一个原型对象</span></span><br><span class="line">CreateObj.prototype; <span class="comment">// &#123; constructor: f CreateObj(),  __proto__: Object&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数有一个prototype属性引用了原型对象，原型对象有一个constructor属性引用了这个构造函数</span></span><br><span class="line"><span class="comment">// 也就是说 构造函数 和 构造函数.prototype.constructor 是一样的，二者循环引用</span></span><br><span class="line">Create.prototype.constructor === CreateObj; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时构造函数的原型链是指向Object的原型对象的，Object的原型链最终指向了null</span></span><br><span class="line">CreateObj.prototype.__proto__ === <span class="built_in">Object</span>.prototype; <span class="comment">// true</span></span><br><span class="line">CreateObj.prototype.__proto__.constructor === <span class="built_in">Object</span>; <span class="comment">// true</span></span><br><span class="line">CreateObj.prototype.__proto__.__proto__ === <span class="literal">null</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 这时候我们创建一个实例</span></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> CreateObj();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时，实例和原型对象关系为</span></span><br><span class="line">obj1.__proto__ === CreateObj.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样。实例、原型对象。构造函数就都对上了号了</span></span><br><span class="line"><span class="comment">// 也可以说：如果A.__proto__ === B.prototype，那么A就是B的实例</span></span><br></pre></td></tr></table></figure>
<p>   如果此刻还不相信实例在原型对象上，可以通过 <code>isPrototypeOf</code> 来判断，它的意思测试一个对象是否在另一个对象的原型链上：</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CreateObj.prototype.isPrototypeOf(obj1); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>   还有一种方式：<code>Object.getPrototypeOf()</code> ，它的意思是返回某个对象的原型：</p>
   <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj1) === CreateObj.prototype; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="原型的层级关系"><a href="#原型的层级关系" class="headerlink" title="原型的层级关系"></a>原型的层级关系</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">CreateObj.prototype.name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> CreateObj();</span><br><span class="line"><span class="keyword">let</span> obj2 = <span class="keyword">new</span> CreateObj();</span><br><span class="line"></span><br><span class="line">obj1.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// abc</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>从上面可以看出来，对象寻找某个属性的时候(例子上就是name)，如果实例上没有，就会去原型对象上查找，如果实例上有，就返回实例上的。</p>
<p>那如果删掉实例上的属性呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">CreateObj.prototype.name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> CreateObj();</span><br><span class="line"></span><br><span class="line">obj1.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> obj1.name;</span><br><span class="line"><span class="built_in">console</span>.log(obj1.name); <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>
<p>可以看出来obj1返回的是原型对象上的name了。</p>
<p>那如何判断name是实例上的还是原型对象上的呢？<code>hasOwnProperty()</code> 就是干这个的，如果属性在实例上就返回true:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">CreateObj.prototype.name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> CreateObj();</span><br><span class="line">obj1.hasOwnProperty(<span class="string">&quot;name&quot;</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">obj1.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">obj1.hasOwnProperty(<span class="string">&quot;name&quot;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>那不管是原型上也好，实例上也好，就只想知道name有没有在obj1上怎么实现呢？<code>in操作符</code> !</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">CreateObj.prototype.name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> CreateObj();</span><br><span class="line"><span class="string">&quot;name&quot;</span> <span class="keyword">in</span> obj1 <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">obj1.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="string">&quot;name&quot;</span> <span class="keyword">in</span> obj1 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>再来看一个可能会用到的例子：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">CreateObj.prototype.name = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">CreateObj.prototype.age = <span class="number">20</span>;</span><br><span class="line">CreateObj.prototype.sex = <span class="string">&quot;male&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(CreateObj.prototype);</span><br><span class="line"><span class="built_in">console</span>.log(keys); <span class="comment">// name, age. sex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> CreateObj();</span><br><span class="line">obj1.name = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">obj1.age = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">let</span> o1Keys = <span class="built_in">Object</span>.keys(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(o1Keys); <span class="comment">// name, age</span></span><br></pre></td></tr></table></figure>
<p>上面可以看到，获取原型对象的键和获取实例的键是不一样的，各自是各自的。如果想列出所有实例的属性，可以通过<code>Object.getOwnPropertyNames()</code> 来获取：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(CreateObj.prototype); </span><br><span class="line"><span class="comment">// [constructor, name, age, sex]</span></span><br></pre></td></tr></table></figure>
<h3 id="原型的特殊语法"><a href="#原型的特殊语法" class="headerlink" title="原型的特殊语法"></a>原型的特殊语法</h3><p>从上面的许多例子可以看到，每次添加一个属性或者方法，都得用 <code>构造函数.prototype</code> 的方式重写一次，很麻烦，所以有更好的写法推荐：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">CreateObj.prototype = &#123;</span><br><span class="line">  name: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  age: <span class="number">50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子里，原型对象指向了一个新的对象，这样会引发一个问题：constructor指向了Object构造函数，解决它的办法是：<strong>自定义constructor要指向的构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">CreateObj.prototype = &#123;</span><br><span class="line">  <span class="title">constructor</span>: <span class="title">CreateObj</span>,</span><br><span class="line">  <span class="title">name</span>: &quot;<span class="title">abc</span>&quot;,</span><br><span class="line">  <span class="title">age</span>: 50</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就把指向的问题改过来了，但是细节来了，这样的 constructor 会创建一个 [[Enumerable]] 为true的属性，而原生的 constructor 默认是不可枚举的，所以，得用到上面说过的 <code>Object.defindProperty </code> 来初始化为false：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> CreateObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">CreateObj.prototype = &#123;</span><br><span class="line">  name: <span class="string">&quot;abc&quot;</span>,</span><br><span class="line">  age: <span class="number">50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(CreateObj.prototype, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  value: CreateObj</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>通过原型模式，我们知道了构造函数、原型和实例的关系：构造函数(CreateObj) 有一个原型(CreateObj.prototype)，原型有一个constructor属性指回构造函数(CreateObj)，实例(obj1)有一个内部指针指向原型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CreateObj.prototype.constructor === CreateObj;</span><br><span class="line">obj1.__proto__ === CreateObj.prototype;</span><br></pre></td></tr></table></figure>
<p>如果原型(CreateObj.prototype)是另一个类型的实例呢？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> OtherObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> other = <span class="keyword">new</span> OtherObj();</span><br><span class="line"></span><br><span class="line">CreateObj.prototype = other</span><br></pre></td></tr></table></figure>
<p>这就意味着:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">CreateObj.prototype.__proto__ ===  OtherObj.prototype;</span><br><span class="line">CreateObj.prototype.constructor == OtherObj;</span><br></pre></td></tr></table></figure>
<p><strong>如果把 CreateObj.prototype 看做一个实例对象，那么实例的 proto 就等于了另一个构造函数的原型，</strong></p>
<p><strong>如果把 CreateObj 单独看做一个构造函数，一开始 Createobj的 prototype 的 constructor 等于 CreateObj 自己，现在它等于 另一个构造函数了。</strong></p>
<p><strong>此时，CreateObj 继承于 OtherObj 了，因为我们把构造函数的原型，当成了一个实例来看待。</strong></p>
<p><strong>这样就构成了一条链：原型链！</strong></p>
<p><em>如果想改变这条原型链，只需要把 CreateObj.prototype 赋值给其他实例就可以了，就相当于 CreateObj.prototype 这个大实例的 proto 指向了另一个构造函数的原型。</em></p>
<p>但是原型链也有缺点，还记得说过一句话么：原型中包含的引用值会在所有实例之间共享！所以属性一般都会在构造函数里，而不在原型上。</p>
<p>还有另一个缺点就是，子类型实例化时不能给父类型的构造函数传参数，也就是说 obj1 不能传参给 OtherObj传递参数。</p>
<h2 id="对象伪装"><a href="#对象伪装" class="headerlink" title="对象伪装"></a>对象伪装</h2><p>前面说了一大堆，其实 CreateObj 是自己，OtherObj也是自己，它们只是有一个原型链关系绑定而已，如果在 CreateObj 里面，把它的 this 指向 OtherObj，那么……对！CreateObj 就可以使用 OtherObj 里面的东西了！</p>
<h3 id="经典继承"><a href="#经典继承" class="headerlink" title="经典继承"></a>经典继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OtherObj</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	OtherObj.call(<span class="built_in">this</span>, <span class="string">&quot;abc&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> CreateObj();</span><br><span class="line">obj1.name <span class="comment">// &quot;abc&quot;</span></span><br></pre></td></tr></table></figure>
<p>官方叫：<strong>盗用构造函数</strong>。</p>
<p>当然解决了引用的问题之后，新的问题来了：OtherObj 里要创建好多方法，而且只能在 OtherObj 中定义方法。</p>
<h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OtherObj</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">OtherObj.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承了属性</span></span><br><span class="line">  OtherObj.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了原型链上的方法</span></span><br><span class="line">CreateObj.prototype = <span class="keyword">new</span> OtherObj();</span><br><span class="line"></span><br><span class="line">CreateObj.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="built_in">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = CreateObj(<span class="string">&quot;abc&quot;</span>, <span class="number">20</span>);</span><br><span class="line">obj1.sayName(); <span class="comment">// abc</span></span><br><span class="line">obj1.sayAge(); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p>综合了原型链和经典继承，使用原型链继承原型上的属性和方法，改变this指向继承实例属性，这样每个实例就都有自己的属性并且共享相同的方法了。</p>
<h3 id="寄生组合继承"><a href="#寄生组合继承" class="headerlink" title="寄生组合继承"></a>寄生组合继承</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">OtherObj</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">OtherObj.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreateObj</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  OtherObj.call(<span class="built_in">this</span>, name);</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">CreateObj.prototype = <span class="keyword">new</span> OtherObj();</span><br><span class="line">CreateObj.prototype.constructor = CreateObj;</span><br><span class="line">CreateObj.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式和组合继承很类似，差别就在于：CreateObj.prototype.constructor = CreateObj。</p>
<p>组合继承的 CreateObj 的原型的构造器指向了 OtherObj，而寄生组合继承指向了 CreateObj 自己，这样相当于 OtherObj 没有给 CreateObj 的原型赋值，而是用了一个 OtherObj 的副本，只改变了原型，其他自己还是自己的。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">DaoDaoLee</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://daodaolee.cn/2021/02/22/重学JavaScript【对象的结构，创建和继承关系】/">https://daodaolee.cn/2021/02/22/重学JavaScript【对象的结构，创建和继承关系】/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://daodaolee.cn">DaoDaoLeeのBlog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Object/">Object</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2021/02/23/%E9%87%8D%E5%AD%A6JavaScript%E3%80%90%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9B%E9%98%B6%E3%80%91/"><i class="fa fa-chevron-left">  </i><span>重学JavaScript【函数的进阶】</span></a></div><div class="next-post pull-right"><a href="/2021/02/19/%E8%B5%84%E6%BA%90%E5%8A%A0%E8%BD%BD%E4%B8%80%E4%B8%88%E7%BA%A2-%E7%BD%AA%E9%AD%81%E7%A5%B8%E9%A6%96%E7%AB%9F%E7%84%B6%E6%98%AFCSP%EF%BC%81/"><span>资源加载一丈红?罪魁祸首竟然是CSP!</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '0fe8487472ec5c0e5482',
  clientSecret: '9fc72b10aa52e8ff87754311bd0fb371e5f6c3ac',
  repo: 'daodaolee.github.io',
  owner: 'daodaolee',
  admin: 'daodaolee',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer class="footer-bg" style="background-image: url(https://i.loli.net/2021/01/23/OvztMyob9GYxBgn.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 - 2021 By DaoDaoLee</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">hitokoto</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script id="ribbon" src="/js/third-party/dynamic-ribbon.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"jsonPath":"live2d-widget-model-wanko"},"display":{"superSample":2,"width":210,"height":420,"position":"left","hOffset":0,"vOffset":-20},"log":false,"tagMode":false});</script></body></html>