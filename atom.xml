<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DaoDaoLeeのBlog</title>
  
  <subtitle>所谓的迷茫，不过是清醒的看着自己沉沦</subtitle>
  <link href="https://daodaolee.cn/atom.xml" rel="self"/>
  
  <link href="https://daodaolee.cn/"/>
  <updated>2021-01-30T14:47:45.158Z</updated>
  <id>https://daodaolee.cn/</id>
  
  <author>
    <name>DaoDaoLee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>知其所以然【Promise篇】</title>
    <link href="https://daodaolee.cn/2021/01/30/%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%E3%80%90Promise%E7%AF%87%E3%80%91/"/>
    <id>https://daodaolee.cn/2021/01/30/%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%E3%80%90Promise%E7%AF%87%E3%80%91/</id>
    <published>2021-01-30T14:29:24.000Z</published>
    <updated>2021-01-30T14:47:45.158Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇讲了 <code>Promise </code> 的概念和简单用法之后，这篇来说下 Promise 内部结构和工作方式，看看它里面都藏了什么东西。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>上篇说道， <code>Promise</code>是一个函数返回的对象(用官话讲就是：一个在将来某个时刻产生一个单一结果的对象，代表了一个值，但是这个值不确定什么时候会被返回)，可以用来进行异步操作，可以拿到操作成功或者失败的结果。异步方法并不会返回最终的值，而是返回一个 Promise，这样才可以链式调用。</p><p>一个 <code>Promise</code> 有三种状态：</p><ol><li>待定(pending)：初始状态，也就是没有成功也没有失败，属于正在进行中</li><li>成功(fulfilled)：操作成功完成</li><li>拒绝(rejected)：操作失败</li></ol><p>待定状态下，要么通过一个值返回成功，要么报错被拒绝。当一个 Promise 在被绑定的时候就已经成功或者拒绝了，那么它就会被后面的逻辑调用，所以在完成异步操作和绑定处理方法之间不会存在竞争关系。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种就是默认绑定了成功的状态</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then()</span><br></pre></td></tr></table></figure><p>如果状态是操作成功或者失败，那么 Promise 就处于 已敲定状态(settled)，可以理解为结束的状态。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这时，&quot;promise&quot; 已经被敲定了。</span></span><br><span class="line"><span class="keyword">const</span> x = promiseA.then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val,val+<span class="number">1</span>) );</span><br><span class="line"><span class="keyword">const</span> y = promiseA.then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val,val+<span class="number">2</span>) );</span><br><span class="line"><span class="built_in">console</span>.log(x, y);</span><br><span class="line"><span class="comment">// x: 777 778</span></span><br><span class="line"><span class="comment">// y: 777 779</span></span><br></pre></td></tr></table></figure><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>在链式调用中，只有当第一个 Promise 执行完毕，从事件队列中移除，才会进行下一个。也就是说 Promise 里面的 return ，执行的是 Promise 被移除(弹出)，当前的返回值替换被弹出的 Promise 原来的位置，接着进行后面的异步操作。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li><p><code>Promise.resolve(value)</code></p><p>该方法返回一个value，如果值是 then，返回的 Promise 对象的最终状态由 then 方法决定，如果没有value，则返回 Promise 对象的状态为 <code>fulfilled</code> ，并且将该状态传到对应的 then 方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li><li><p><code>Promise.reject(reason)</code></p><p>该方法返回一个状态为失败的 Promise 对象，并将失败信息传递下去。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;resolved&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> reject = <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>))</span><br><span class="line">  .then(resolve, reject)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Error: fail</span></span><br></pre></td></tr></table></figure></li><li><p><code>Promise.all(iterable)</code></p><p>该方法返回一个新的 Promise 对象，当 iterable 里的所有 Promise 都成功之后，才会触发成功。一旦有任何一个失败，就会立即出发该 Promise 对象失败。</p><p>成功：返回的值的顺序和调用的时候的排序一致。</p><p>失败：返回第一个触发失败的错误信息。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve(<span class="string">&quot;foo&quot;</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// [3, &quot;123&quot;, &quot;foo&quot;]</span></span><br></pre></td></tr></table></figure><ul><li><p>如果传入的参数是空数组，就直接返回一个 已完成 状态的 Promise。</p></li><li><p>如果传入的的参数不包含任何 promise，就直接返回一个 已完成 状态的 Promise。</p></li><li><p>其他情况就会返回 pending 状态的 promise。这个返回的 <code>promise</code> 之后会在所有的 promise 都完成或者有一个失败时，异步地变为完成或者失败。</p></li></ul></li><li><p><code>Promise.allSettled(iterable)</code></p><p>等所有 Promise 状态都变成 <code>已敲定(settled)</code>，也就是每个 Promise 都变成成功状态或者已拒绝之后，返回一个 Promise，里面包含了每个 Promise的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject(<span class="string">&quot;foo&quot;</span>), <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled([p1, p2]).</span><br><span class="line">  then(<span class="function"><span class="params">results</span> =&gt;</span> <span class="built_in">console</span>.log(result));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* [&#123;</span></span><br><span class="line"><span class="comment">    status: &quot;fulfilled&quot;, value: 3</span></span><br><span class="line"><span class="comment">  &#125;,&#123;</span></span><br><span class="line"><span class="comment">  status: &quot;rejected&quot;, reason: &quot;foo&quot;</span></span><br><span class="line"><span class="comment">  &#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> 传入的参数得是一个数组，每个参数都是 <code>Promise</code>，每个结果都有一个 <code>status</code> 字符串，代表状态。</p></li><li><p><code>Promise.race(iterable)</code></p><p>当 iterable 参数里任意一个子 promise 成功或者失败，就结束。接着就会调用父promise后面绑定的相应逻辑，就会接着往下运行(只要一个有结果就会接着网后走)。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve(<span class="string">&quot;1&quot;</span>, <span class="number">5000</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve(<span class="string">&quot;2&quot;</span>, <span class="number">1000</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>通过 <code>Promise.prototype</code> ，可以看到它的原型链上有个三个方法：</p><ol><li><p><code>Promise.prototype.then(onFulfilled, onRejected)</code></p><p>给当前的 Promise 添加 解决 和 拒绝 回调，并返回一个 Promise，所以可以进行链式调用。</p></li><li><p><code>Promise.prototype.catch(onRejected)</code></p><p>给当前的 Promise 设置为 拒绝状态 ，并返回一个 Promise。</p><p>该方法其实就是 <code>.then(null, rejection)</code> ，或者 <code>.then(undefined, rejection)</code>的别名。如果有多个 catch，那么当前 catch 捕获的是上一个报错。</p></li><li><p><code>Promise.prototype.finally(onFinally)</code></p><p>给当前的 Promise 添加一个回调的事件处理，在 Promise 解析完毕后，返回一个 新的Promise对象。无论状态是成功或者失败，该回调都会在当前promise运行结束后调用，</p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>知道了 <code>Promise</code> 的内部结构之后，我们来简单的实现一个 Promise（实现的细节要与规范符合）。</p><p><code>myPromis </code> 实现思路：</p><ol><li>Promise 是 new 出来的，而且需要一个 executor 执行器</li><li>executor 带入 resolve 和 reject</li><li>状态只能从 pending 到 fulfilled 或者 rejected</li><li>状态一旦确认不可改变</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  _this.status = <span class="string">&quot;pending&quot;</span>; <span class="comment">//状态</span></span><br><span class="line">  _this.onFulfilled = []; <span class="comment">//成功回调</span></span><br><span class="line">  _this.onRejected = []; <span class="comment">//失败回调</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//定义resolve  </span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_this.status === <span class="string">&quot;pending&quot;</span>)&#123;</span><br><span class="line">      _this.status = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">      _this.value = value;</span><br><span class="line">      _this.onFulfilled.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//定义reject</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_this.status === <span class="string">&quot;pending&quot;</span>)&#123;</span><br><span class="line">      _this.status === <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      _this.reason = reason;</span><br><span class="line">      _this.onRejected.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//调用  </span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此呢，通过一个 <code>myPromise</code> 就初始化好了，里面包括了状态，值和两个回调。接下来我们去构造 <code>then</code> 方法。</p><ol><li>then 方法有两个参数，分别是 myPromise 的两个回调(onFulfilled 和 onRejected)</li><li>then 方法是在 myPromise 状态结束之后调用的：<ol><li>成功：执行 onFulfilled，把值传进去</li><li>失败：执行onRejected，把错误原因传进去</li><li>待定：等状态确定后再执行成功或者失败，所以要先把成功和失败的回调存起来</li></ol></li><li>then 方法可以链式调用，每次调用都返回一个 promise</li><li>then的结果<ol><li>如果是一个结果，就传递给下一个 then 的成功回调(onFulfilled)</li><li>如果是一个异常，就传递给下一个 then 的失败回调(onRejected)</li><li>如果返回的是一个 promise，就得等待这个 promise，执行完之后，成功就走下一个 then 的成功，否则就走下一个 then 的失败</li></ol></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason&#125;;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line"> <span class="keyword">let</span> promiseThen = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 返回的状态是成功，一个结果</span></span><br><span class="line">   <span class="keyword">let</span> fulfilledFn = </span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> fn = onFulfilled(_this.value);</span><br><span class="line">         resolvePromise(promiseThen, fn, resolve, reject);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">         reject(e);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,<span class="number">0</span>);</span><br><span class="line">   <span class="comment">// 返回的状态是失败，一个异常</span></span><br><span class="line">   <span class="keyword">let</span> rejectedFn = </span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> fn = onRejected(_this.reason);</span><br><span class="line">         resolvePromise(promiseThen, fn, resolve, reject);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">         reject(e);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">switch</span>(_this.status)&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;fulfilled&quot;</span>:</span><br><span class="line">       &#123;</span><br><span class="line">         fulfilledFn();</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;rejected&quot;</span>:</span><br><span class="line">       &#123;</span><br><span class="line">         rejectedFn();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;pending&quot;</span>:</span><br><span class="line">       &#123;</span><br><span class="line">         _this.onFulfilled.push(fulfilledFn);</span><br><span class="line">         _this.onRejected.push(rejectedFn);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promiseThen, fn, resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(promiseThen === fn)&#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fn &amp;&amp; <span class="keyword">typeof</span> fn === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> fn === <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> used; <span class="comment">//PromiseA+2.3.3.3.3 只能调用一次</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = fn.then;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">        then.call(fn, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(used) <span class="keyword">return</span>;</span><br><span class="line">          used = <span class="literal">true</span>;</span><br><span class="line">          resolvePromise(promiseThen, y, resolve, reject);</span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(used) <span class="keyword">return</span>;</span><br><span class="line">          used = <span class="literal">true</span>;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(used) <span class="keyword">return</span>;</span><br><span class="line">        used = <span class="literal">true</span>;</span><br><span class="line">        resolve(fn);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span>(used) <span class="keyword">return</span>;</span><br><span class="line">      used = <span class="literal">true</span>;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关其他的方法实现，可以查看<a href="https://github.com/YvetteLau/Blog/issues/2">Promise的源码实现（完美符合Promise/A+规范）</a>。</p><p>至此 <code>Promise </code> 的用法就结束了，实际项目运用中会配合<strong>事件循环机制</strong>一起使用，后文再叙。</p><p>参考资料：</p><ul><li><a href="https://promisesaplus.com/">Promises/A+</a></li><li><a href="https://github.com/YvetteLau/Blog/issues/2">Promise的源码实现（完美符合Promise/A+规范）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇讲了 &lt;code&gt;Promise &lt;/code&gt; 的概念和简单用法之后，这篇来说下 Promise 内部结构和工作方式，看看它里面都藏了什么东西。&lt;/p&gt;
&lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;</summary>
      
    
    
    
    
    <category term="promise" scheme="https://daodaolee.cn/tags/promise/"/>
    
    <category term="异步" scheme="https://daodaolee.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>知其然【Promise篇】</title>
    <link href="https://daodaolee.cn/2021/01/30/%E7%9F%A5%E5%85%B6%E7%84%B6%E3%80%90Promise%E7%AF%87%E3%80%91/"/>
    <id>https://daodaolee.cn/2021/01/30/%E7%9F%A5%E5%85%B6%E7%84%B6%E3%80%90Promise%E7%AF%87%E3%80%91/</id>
    <published>2021-01-30T14:28:15.000Z</published>
    <updated>2021-01-30T14:45:36.392Z</updated>
    
    <content type="html"><![CDATA[<p>要想掌握 <code>Promise</code>，先从概念和使用方法入手，而后刨根它的原理，方可大成。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 抛去所有和它有关的东西，<code>Promise</code> 这个词，翻译过来是 <strong>承诺</strong> 的意思，那么我们可以猜想，它是不是一个有关逻辑状态的东西呢。</p><p><strong><code>Promise</code> 是一个对象</strong>，它代表了一个异步操作的 <strong>完成</strong> 或者 <strong>失败</strong>，本质上它是一个函数返回的对象，我们可以在他上面绑定回调函数，这样就不需要在一开始把回调函数作为参数传入这个函数了。</p><p>意思是说：</p><ol><li>首先我们认定了 <code>Promise</code>是一个函数</li><li>它是一个返回了管理异步操作状态(成功 / 失败)的函数</li><li>它默认绑定了回调函数</li><li>它的返回值是一个对象</li></ol><p>那我们可以尝试着写一个 <strong>伪Promise</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> successCallback = <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> failedCallback = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> error</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;params, successCallback, failedCallback&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 可以这样调用</span></span><br><span class="line"><span class="keyword">const</span> promise = fn(params);</span><br><span class="line">promise.then(successCallback, failedCallback);</span><br><span class="line"><span class="comment">// 2. 也可以这样调用</span></span><br><span class="line">fn(params).then(successCallback, failedCallback);</span><br></pre></td></tr></table></figure><p>我们把这称为 <em>异步函数调用</em> ，在使用 <code>Promise</code> 的时候，会有以下约定：</p><ol><li>在本轮事件循环运行完成之前，回调函数是不会被调用的</li><li>即使异步操作结束，在这之后通过 <code>then()</code> 添加的回调函数也会被执行</li><li>通过 <code>then()</code> 可以添加多个回调函数，它们按照插入的顺序依次执行</li></ol><p>所以：<code>Promise</code> 很棒的一点就是 <strong>链式调用</strong>，下面我们通过链式调用简单使用一下。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>我们先模拟一个环境：连续执行多个异步操作，上个操作结束后，才开始下一个，并带上上一个的返回值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以这样写</span></span><br><span class="line"><span class="keyword">const</span> promise1 = fn();</span><br><span class="line"><span class="keyword">const</span> promise2 = promise.then(successCB, failedCB);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以这样写</span></span><br><span class="line"><span class="keyword">const</span> promise2 = fn().then(successCB, failedCB);</span><br></pre></td></tr></table></figure><p>在上面的例子里， <code>Promise2</code> 表示 <code>fn</code>() 函数的完成，也表示了传入的<code> successCB()</code> 或者 <code>failedCB()</code> 的完成，当然这两个函数也返回了一个 Promise 对象，从而形成一个异步操作。</p><p>此刻我们就解决了 <em>回调地域</em> 的问题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  fn1(result, <span class="function"><span class="params">newResult</span> =&gt;</span> &#123;</span><br><span class="line">    fn2(newResult, <span class="function"><span class="params">finalResult</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//do something...</span></span><br><span class="line">    &#125;, failedCB)</span><br><span class="line">  &#125;, failedCB)</span><br><span class="line">&#125;, failedCB)</span><br></pre></td></tr></table></figure><p>上面的回调地域，我们把回调绑定到 Promise 上，形成一个 Promise 链，再看：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fn1(result);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">newResult</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fn2(newResult);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">finalResult</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//do something...</span></span><br><span class="line">&#125;).catch(failedCB)</span><br><span class="line"></span><br><span class="line"><span class="comment">//上方的catch(failedCB) 就是 then(null, failedCB)的缩写</span></span><br></pre></td></tr></table></figure><p>看起来清爽了很多🎉。</p><p>那么在这个时候考虑一个问题，如果在一个链式操作中，使用了一个 <code>catch()</code>，再次继续回调怎么办？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;初始化&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;有哪里不对了&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行「这个」&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行「那个」&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行「这个」，无论前面发生了什么&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 执行“那个”</span></span><br><span class="line"><span class="comment">// 执行“这个”，无论前面发生了什么</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：因为抛出了错误 <em>有哪里不对了</em>，所以前一个 <em>执行「这个」</em> 没有被输出。</p><h2 id="时序问题"><a href="#时序问题" class="headerlink" title="时序问题"></a>时序问题</h2><p>在理想状态下，所有的异步函数其实都已经返回了 Promise 了，但是还是有些特殊的回调比如定时器，如果混用 Promise 和 定时器 可能会造成时序问题，所以，最好的做法是把有问题的函数封装，永远不要直接调用它们：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line"></span><br><span class="line">wait(<span class="number">1000</span>).then(<span class="function">()=&gt;</span>&#123;fn()&#125;)</span><br></pre></td></tr></table></figure><p><code>then()</code> 方法的函数会被放到一个微任务队列中，而不是立即执行，这意味着它是在JS事件队列的所有运行时结束了，并且事件队列被清空了之后，才开始执行的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>)).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>); <span class="comment">// 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure><p><em>后期会补一篇循环机制的文章，专门讲下事件队列</em>。</p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>平常用的比较多的就是 <code>Promise.all()</code> 和 <code>Promise.race()</code> 了，它们两个是并行运行异步的方法，也就是都执行完之后才可以操作结果，但是坏处就是只要有一个失败，就会中断并抛出异常。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([fn1(), fn2()])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// [result1,result2]</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//返回最先被reject失败的状态</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Promise.race()</code> 与 <code>Promise.all() </code> 不一样的地方就是，按走完的时间顺序排序结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([fn1(), fn2()])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// [result2, result1] or [result1, result2]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意：一定要在 <code>then()</code> 方法里返回一个 Promise 对象(总是返回或终止 Promise)，这样才是一条完整的可异步执行的链。</strong></p><p>上面简单的把 <code>Promise</code> 的概念和简单使用阐述了一下，主要针对的是对 promise 不熟悉的朋友，也算是一个简单的回顾。“知其所以然【Promise篇】“ 会把里面的细节讲一下。</p><p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">使用Promise</a></li><li><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html">大白话讲解Promise（一）</a></li><li><a href="https://zhuanlan.zhihu.com/p/24684803">这是一篇傻瓜都能看懂的Promises文章！</a></li><li><a href="https://wiki.jikexueyuan.com/project/javascript-promise-mini-book/what-is-the-promise.html">什么是Promise</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要想掌握 &lt;code&gt;Promise&lt;/code&gt;，先从概念和使用方法入手，而后刨根它的原理，方可大成。&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt; 抛去所有和它有关的</summary>
      
    
    
    
    
    <category term="promise" scheme="https://daodaolee.cn/tags/promise/"/>
    
    <category term="异步" scheme="https://daodaolee.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>重装Mac历程</title>
    <link href="https://daodaolee.cn/2021/01/22/%E9%87%8D%E8%A3%85Mac%E5%8E%86%E7%A8%8B/"/>
    <id>https://daodaolee.cn/2021/01/22/%E9%87%8D%E8%A3%85Mac%E5%8E%86%E7%A8%8B/</id>
    <published>2021-01-22T08:08:13.000Z</published>
    <updated>2021-01-25T09:03:04.939Z</updated>
    
    <content type="html"><![CDATA[<p>自从升级了 <code>Big Sur</code> 之后，本以为 Mac变为 iPad 会更轻便更舒服，然而，平常工作状态下，cpu直飙60%左右，转速也基本在2000，用Node打个包，转速能到5000，真的简直了。常用软件虽然也慢慢的都适配了 Big Sur，但是总感觉有点不舒服（iPreview直接向下不兼容了……淦，不知道其他有没有）。于是乎在工作稳定和体验新系统的权衡之下，还是妥妥的降级到了 <code>mojave</code>。还是熟悉的配方，还是熟悉的味道，还是熟悉的百分之十以下的cpu，还是熟悉的一千多转速，哪里都很香。</p><p>因为只熟悉 <code>windows</code> 的系统，<code>Mac</code> 的话，自己还没有搞过系统，以前有过一次还是从淘宝上花钱让别人远程装了的……网上找了一堆资料，最终总结出比较踏实的重装流程，然后就开始了：</p><ol><li><p>下载系统⬇</p><p>到  <code>App Store </code> 下载相应的系统，如果在 <code>App Store</code> 里面找不到，那就去官网下载（<a href="https://apps.apple.com/cn/app/macos-big-sur/id1526878132?ls=1&mt=12">Big Sur系统链接</a>，<a href="https://apps.apple.com/cn/app/macos-catalina/id1466841314?ls=1&mt=12">Catalina系统链接</a>，<a href="https://apps.apple.com/cn/app/macos-mojave/id1398502828?ls=1&mt=12">Mojave系统链接</a>，<a href="https://apps.apple.com/cn/app/macos-high-sierra/id1246284741?ls=1&mt=12">High Sierra系统链接</a>），因为有可能商店里只有最新的系统。</p><p>下载好之后可以在 <code>Launchpad</code>界面看到一个安装程序。如果是要升级系统，直接点击就可以了，如果要降级，别点，留着。</p></li><li><p>做系统盘💿</p><p>接下来就是格式化U盘，去磁盘工具里，抹掉U盘，名称先改成 <code>MyVolume</code> ，格式为 <code>Mac OS扩展 (日志式)</code>。抹完之后就开始制作系统盘了。</p><p>根据想做的系统盘，在终端里输入以下命令（注意命令里的 <code>MyVolume</code>就是上面系统盘的名称）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Catalina (10.15)</span></span><br><span class="line">sudo /Applications/Install\ macOS\ Catalina.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mojave (10.14)</span></span><br><span class="line">sudo /Applications/Install\ macOS\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</span><br><span class="line"></span><br><span class="line"><span class="comment"># High Sierra (10.13)</span></span><br><span class="line">sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</span><br></pre></td></tr></table></figure><p>然后会输入密码，输入之后回车，接着输入 <code>y</code> ，再回车就可以看到安装的进度条了，大概3~5分钟。</p><p>提示<code>  Done</code> 之后，就制作完成了。</p></li><li><p>安装✌</p><p>电脑关机，一直按住 <code>⌥alt</code>键( 也就是option )，然后开机，开机也要一直按住 <code>⌥alt</code> ，界面会出来一个磁盘和一个安装系统的图标。进去右边，选择磁盘工具，左侧选择“Macintosh HD”( 注意看清楚是“内置”栏下面的，不要选“磁盘映像”栏下面的 )，格式默认选择 <code>APFS</code> ，没有的话就选择 <code>Mac OS 扩展( 日志式 )</code>。抹完之后，点击关闭，回到之前的界面，选择 <code>安装macOS</code>。</p><p>本以为到这里就可以结束了，然而我的电脑报错了！</p><p><img src="https://i.loli.net/2021/01/25/kXiYCrSh6IRs4qj.jpg"></p><p>本来有点惊讶，还以为哪里出错了，看完这个提示之后感觉应该不是问题，就按着上面的接着操作了，重新启动后，菜单栏有个安全性实用工具，把 <code>外部启动</code> 修改为 <code>允许从外部介质启动</code> 就可以了，有点像BIOS更改启动项的味道。接下来一切顺利，重装之后是真干净，什么都没有，Xcode，Java全部干掉了，然而还是硬着头皮装回来一部分。</p><p>整个过程还是比较顺利的，有想降级的朋友可以试着降级，不必担心什么，只要东西备份好就可以了，我有内测阿里云盘的权限之后，把东西都放上去了。速度还可以，不太舒服的地方就是下载的时候不能下载文件夹，只能下载文件，有点头疼。</p><p>over~👨‍💻</p></li></ol><p>参考资料:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/39103887">macOS 重装系统 Mojave Catalina Big Sur 升级 降级mac OS</a></li><li><a href="https://www.zhihu.com/question/21454213">macOS 系统如何重装？</a></li><li><a href="https://support.apple.com/zh-cn/HT204904">如何重新安装 macOS</a></li><li><a href="https://support.apple.com/zh-cn/HT208198">关于“启动安全性实用工具”</a></li><li><a href="https://discussionschinese.apple.com/thread/250455252">重装系统安装关键性更新失败</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自从升级了 &lt;code&gt;Big Sur&lt;/code&gt; 之后，本以为 Mac变为 iPad 会更轻便更舒服，然而，平常工作状态下，cpu直飙60%左右，转速也基本在2000，用Node打个包，转速能到5000，真的简直了。常用软件虽然也慢慢的都适配了 Big Sur，但是总感</summary>
      
    
    
    
    
    <category term="Mac" scheme="https://daodaolee.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>http的option请求</title>
    <link href="https://daodaolee.cn/2019/06/24/http%E7%9A%84option%E8%AF%B7%E6%B1%82/"/>
    <id>https://daodaolee.cn/2019/06/24/http%E7%9A%84option%E8%AF%B7%E6%B1%82/</id>
    <published>2019-06-24T10:50:08.000Z</published>
    <updated>2021-01-25T07:54:09.324Z</updated>
    
    <content type="html"><![CDATA[<p>先看两张图：</p><p><img src="https://i.loli.net/2019/06/20/5d0b73254660812409.png"></p><p><img src="https://i.loli.net/2019/06/20/5d0b732a2829499623.png"></p><p>流程是这样：选择支付方式，填入充值金额，跳转到“选择银行卡界面”，但是在跳转的过程中走了2次<code>get_card</code>请求。</p><p>由于模块是H5纯静态页面，肯定会遇到跨域的问题，之前是用<code>jsonp</code>解决的，但是现在需要给后端传一堆<code>headers</code> 头部信息，然后，jsonp就不行了，因为他的实质是src标签，然后用callback传的，而且只能传get，所以这次接口的改动，只能让后端配置CORS了，也就是<code>Allow-Control-Allow-Origin: *</code> 和<code>Allow-Control-Allow-Methods:GET,POST</code> 让后端配置这个就可以了，再保险点，把<code>*</code> 变成<code>访问地址</code> ，然后就出现了上面的情况，第一次的<code>Request Method:OPTION</code> ，而且没有发送请求头，第二次就是 正常的post了。</p><p>出现第一次的原因是探测请求，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。</p><blockquote><p>在ajax中出现options请求，也是一种提前探测的情况，ajax跨域请求时，如果请求的是json，就属于复杂请求，因此需要提前发出一次options请求，用以检查请求是否是可靠安全的，如果options获得的回应是拒绝性质的，比如404\403\500等http状态，就会停止post、put等请求的发出。</p></blockquote><p>如果你查资料(W3C规范)，你会发现在跨域请求中，分为简单请求（get和部分post，post时content-type属于application/x-www-form-urlencoded，multipart/form-data，text/plain中的一种）和复杂请求。而复杂请求发出之前，就会出现一次options请求。</p><p>参考资料：</p><p><a href="http://www.tangshuang.net/2271.html">jquery ajax 请求中多出现一次OPTIONS请求及其解决办法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先看两张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/20/5d0b73254660812409.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/20/5d0b732a282</summary>
      
    
    
    
    <category term="FE" scheme="https://daodaolee.cn/categories/FE/"/>
    
    <category term="http" scheme="https://daodaolee.cn/categories/FE/http/"/>
    
    
    <category term="http" scheme="https://daodaolee.cn/tags/http/"/>
    
    <category term="option" scheme="https://daodaolee.cn/tags/option/"/>
    
  </entry>
  
  <entry>
    <title>form表单提交的submit和ajax区别</title>
    <link href="https://daodaolee.cn/2019/01/23/form%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E7%9A%84submit%E5%92%8Cajax%E5%8C%BA%E5%88%AB/"/>
    <id>https://daodaolee.cn/2019/01/23/form%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E7%9A%84submit%E5%92%8Cajax%E5%8C%BA%E5%88%AB/</id>
    <published>2019-01-23T13:05:22.000Z</published>
    <updated>2021-01-25T07:54:07.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><ul><li>submit：更新数据完成后，需要<strong>转到一个空白的页面</strong>再对原页面进行提交后的处理，即重绘。</li><li>ajax：异步进行，直接返回原页面进行提交后的处理，比submit少增加一个页面，即局部刷新。</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>ajax：出于安全性的考虑，不能对文件进行操作，所以不可以通过ajax来实现文件上传</li><li>submit：通过隐藏form的submit可以实现文件上传</li></ul><h2 id="form默认提交"><a href="#form默认提交" class="headerlink" title="form默认提交"></a>form默认提交</h2><p>如果想要submit后<strong>不刷新页面</strong>，在该方法的最后加上 <code>return false</code> ，就可以了。</p><p><em><code>return false</code> 的含义不是阻止事件继续向顶层元素传播，而是阻止浏览器对事件的默认处理方式。在js中，它的作用一般是用来取消默认动作的。</em></p><p><em><code>return false</code> 等效于 <code>window.event.returnValue = false</code></em> 。</p><blockquote><p>因为原页面用 form 提交到另一个域名之后，原页面的脚本无法获取新页面中的内容。所以浏览器认为这是安全的。而 AJAX 是可以读取响应内容的，因此浏览器不能允许你这样做。 如果你细心的话你会发现，其实请求已经发送出去了，你只是拿不到响应而已。 所以浏览器这个策略的本质是，一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容。但浏览器并不阻止你向另一个域名发送请求。 ——来自知乎</p></blockquote><p>有关同源策略和跨域，可以参考 <a href="https://mp.weixin.qq.com/s?__biz=MzU0OTExNzYwNg==&mid=2247483685&idx=1&sn=543e9736146405e9e5b37ec5a1c4b448">跨域的那些事儿</a></p><p>参考资料：</p><p><a href="https://www.cnblogs.com/zhujiabin/p/4901167.html">Ajax提交与传统Form表单提交的区别说明</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;页面&quot;&gt;&lt;a href=&quot;#页面&quot; class=&quot;headerlink&quot; title=&quot;页面&quot;&gt;&lt;/a&gt;页面&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;submit：更新数据完成后，需要&lt;strong&gt;转到一个空白的页面&lt;/strong&gt;再对原页面进行提交后的处理，即重绘。&lt;/l</summary>
      
    
    
    
    <category term="FE" scheme="https://daodaolee.cn/categories/FE/"/>
    
    <category term="form" scheme="https://daodaolee.cn/categories/FE/form/"/>
    
    
    <category term="form" scheme="https://daodaolee.cn/tags/form/"/>
    
    <category term="ajax" scheme="https://daodaolee.cn/tags/ajax/"/>
    
  </entry>
  
</feed>
