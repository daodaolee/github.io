<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>DaoDaoLeeのBlog</title>
  
  <subtitle>所谓的迷茫，不过是清醒的看着自己沉沦</subtitle>
  <link href="https://daodaolee.cn/atom.xml" rel="self"/>
  
  <link href="https://daodaolee.cn/"/>
  <updated>2021-02-01T16:35:33.643Z</updated>
  <id>https://daodaolee.cn/</id>
  
  <author>
    <name>DaoDaoLee</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Async/Await】JS异步终极方案</title>
    <link href="https://daodaolee.cn/2021/02/01/%E3%80%90Async-Await%E3%80%91JS%E5%BC%82%E6%AD%A5%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88/"/>
    <id>https://daodaolee.cn/2021/02/01/%E3%80%90Async-Await%E3%80%91JS%E5%BC%82%E6%AD%A5%E7%BB%88%E6%9E%81%E6%96%B9%E6%A1%88/</id>
    <published>2021-02-01T12:50:05.000Z</published>
    <updated>2021-02-01T16:35:33.643Z</updated>
    
    <content type="html"><![CDATA[<p>之前我们讲了 <code>Promise</code> 的内部结构以及用法，这篇来说下另一个老生常谈的问题：<code>Async/Await</code> 。</p><p>在 <code>Promise</code> 出现之后，确实解决了很多异步执行方面的坑，可以说它在那个时候是无人能敌的。但是，慢慢的发现，仍然有一些问题浮出了水面，比如 <code>then</code> 方法其实还是一个回调，多个 then 连起来执行看起来还是繁琐，又比如报错是在 <code>catch</code> 中，能不能让输出和报错放在统一层呢，又比如请求接口，做了一个判断，是直接返回该数据还是要再获取别的数据，这种情况很有可能会陷入一个 <strong>嵌套地域</strong> 中……而 <code>Async/Await</code> 就是处理这些问题的较佳方案。</p><p>被称为 <strong>Promise的语法糖</strong> 的 async/await 的写法是什么样呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">rsolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">fn().then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>把所有的输出放到了 <strong>then</strong> 方法中，并且支持链式操作，如果有嵌套就一直 <strong>then</strong> 下去。</p><p>而用 <code>async/await </code> 如何写呢？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">rsolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&quot;123&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="keyword">await</span> fn();</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line">result();</span><br></pre></td></tr></table></figure><p>我们可以在方法外部操作获取的值。</p><p>从字面的意思来看，<strong>async</strong> 是”异步” 的意思，<strong>await</strong> 是“等待”的意思，所以应该很好理解：async 相当于声明了一个进行异步的方法，而 await 用于等待一个异步执行完成的结果。</p><p>async 和 await 必须遵循以下规则：</p><ol><li>await 只能在 async 内，不然会报语法错误、</li><li>async方法内可以有多个 await 表达式。</li><li>await 无法捕捉到 promise 对象 reject 的错误信息，需要在 async 方法后面 catch 错误信息。</li><li>async 方法需要主动 return 所需参数</li></ol><p>再补充一点有关概念的解释：</p><ol><li><p>返回值</p><p>async 其实是一个 <code>Promise</code> ，这个 promise 要么通过一个由 async 函数返回的值被解决，要么会通过一个从 async 函数抛出的异常被拒绝。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>进程</p><p>async可以包含多个 await 表达式，await 表达式会暂停整个 async 函数的执行进程，只有当其等待的 promise 异步结束后才会继续往下走。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line"><span class="comment">// 1,2,3</span></span><br></pre></td></tr></table></figure></li><li><p>去掉 await</p><p>如果在一个 async 方法内，没有 await 表达式，那么这个方法内的逻辑是同步运行的，如果有一个 await 表达式，那么 async 方法一定会异步执行。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function">() =&gt;</span> <span class="literal">undefined</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>发生了什么</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fn1 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">const</span> fn2 = <span class="keyword">await</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br></pre></td></tr></table></figure><p>以上代码其实进行了三个阶段：</p><ol><li>fn1 中，await等待 promise 结束，此时把 test 的进程暂停，不往下走了。</li><li>第一个 promise 结束后，test 变成了活跃状态，开始继续往下走，将 <strong>1</strong> 作为返回结果给 fn1 ，此时 promise 状态为 fulfilled，接下来 test 进行到第二个 await 区域， test 再次被暂停。</li><li>第二个 promise 结束后，fn2 被赋值为 <strong>2</strong> ，之后 test 正常同步执行。</li></ol></li></ol><p>从以上可以看出来，<code>Promise</code> 是对异步过程进行了封装，有点函数式编程的感觉，而 <code>async/await</code> 是继续进程的机制走的，保存上下文，逻辑控制权暂停和继续，恢复上下文，更准确地表达了 <strong>异步</strong> 这个概念。</p><p>下面我们再来举两个例子，来看下 async 在某些应用场景下的好处。</p><ol><li><p>获取用户信息，然后接下来操作这些信息，这两个操作需要有先后顺序。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">&quot;用户信息拿到了！&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOtherInfo</span>(<span class="params">userInfo</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// do something   </span></span><br><span class="line">      resolve(<span class="string">&quot;用户信息操作完毕了！&quot;</span>)</span><br><span class="line">    &#125;,<span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">collect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> info1 = <span class="keyword">await</span> getUserInfo();</span><br><span class="line">  consoel.log(info1)</span><br><span class="line">  <span class="keyword">let</span> info2 = <span class="keyword">await</span> getOtherInfo(info1);</span><br><span class="line">  <span class="built_in">console</span>.log(info2)</span><br><span class="line">&#125;;</span><br><span class="line">collect();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1秒后打印 info1</span></span><br><span class="line"><span class="comment">// 再过一秒打印 info2</span></span><br></pre></td></tr></table></figure></li><li><p>当请求时间不知道多久的情况下，仍然从上到下挨个执行</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定时器模拟请求</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">time</span>(<span class="params">ms</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">`进行了<span class="subst">$&#123;ms&#125;</span>毫秒`</span>);</span><br><span class="line">    &#125;, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">collect</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;-----开始-----&quot;</span>)</span><br><span class="line">  <span class="keyword">const</span> t1 = <span class="keyword">await</span> time(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(t1);</span><br><span class="line">  <span class="keyword">const</span> t2 = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([time(<span class="number">3000</span>), time(<span class="number">2000</span>), time(<span class="number">1000</span>)]);</span><br><span class="line">  <span class="built_in">console</span>.log(t2);</span><br><span class="line">  <span class="keyword">const</span> t3 = <span class="keyword">await</span> <span class="built_in">Promise</span>.race([time(<span class="number">1000</span>, time(<span class="number">5000</span>), time(<span class="number">2000</span>))]);</span><br><span class="line">  <span class="built_in">console</span>.log(t3);</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&quot;-----结束-----&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">collect();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// -----开始-----</span></span><br><span class="line"><span class="comment">// 2秒后： 进行了2000毫秒</span></span><br><span class="line"><span class="comment">// 2秒后： [&quot;进行了3000毫秒&quot;, &quot;进行了2000毫秒&quot;, &quot;进行了1000毫秒&quot;]</span></span><br><span class="line"><span class="comment">// 2秒后： 进行了 2000毫秒</span></span><br><span class="line"><span class="comment">// -----结束-----</span></span><br></pre></td></tr></table></figure></li></ol><p>一般情况下，<code>async/await</code> 的写法和上面类似，接下来我们来讲一下报错的话，如何捕获异常(毕竟还是要考虑报错的情况的)。</p><p>首先，<code>async</code> 会返回一个 <code>Promise</code> ，而 Promise 有 <code>.catch</code> 方法去捕获异常，所以我们可以这样：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过下面这种方法可以捕获错误</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fn();</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;).catch(<span class="function"><span class="params">e</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//do something  </span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>而 <code>await</code> 也会返回一个 <code>Promise</code> ，所以我们可以在 await 后面接上 <code>.catch</code>：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">await</span> fn().catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来，JS自带 <code> try/catch</code> 方法来捕获异常，我们可以在代码中这样使用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> v1 = <span class="keyword">await</span> fn1();</span><br><span class="line">    <span class="keyword">const</span> v2 = <span class="keyword">await</span> fn2();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>然而以上的方法如果成堆的出现，还是会冗余，功能实现了，改起来依旧头疼，这里可以参考 <a href="https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/">这位大佬</a> 的写法，把所有的报错和输出都放到同一层，很值得学习：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">to</span>(<span class="params">promise</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> promise.then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="literal">null</span>, data];</span><br><span class="line">  &#125;)</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span> =&gt;</span> [err]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncTask</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> err, user, savedTask;</span><br><span class="line"></span><br><span class="line">  [err, user] = <span class="keyword">await</span> to(UserModel.findById(<span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span>(!user) <span class="keyword">throw</span> <span class="keyword">new</span> CustomerError(<span class="string">&#x27;No user found&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  [err, savedTask] = <span class="keyword">await</span> to(TaskModel(&#123;<span class="attr">userId</span>: user.id, <span class="attr">name</span>: <span class="string">&#x27;Demo Task&#x27;</span>&#125;));</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="keyword">throw</span> <span class="keyword">new</span> CustomError(<span class="string">&#x27;Error occurred while saving task&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(user.notificationsEnabled) &#123;</span><br><span class="line">    <span class="keyword">const</span> [err] = <span class="keyword">await</span> to(NotificationService.sendNotification(user.id, <span class="string">&#x27;Task Created&#x27;</span>));  </span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">console</span>.error(<span class="string">&#x27;Just log the error and continue flow&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后补充一个知识点：串行和并行，这个在开发过程中比较实用：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getB</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span><br><span class="line">    resolve(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> getA();</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">await</span> getB();</span><br><span class="line">  <span class="built_in">console</span>.log(a,b)</span><br><span class="line">  <span class="comment">// a b</span></span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> tempA =  getA();</span><br><span class="line">  <span class="keyword">let</span> tempB =  getB();</span><br><span class="line">  <span class="keyword">let</span> a = <span class="keyword">await</span> tempA;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="keyword">await</span> tempB;</span><br><span class="line">  <span class="built_in">console</span>.log(a,b)</span><br><span class="line">  <span class="comment">// a b</span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>上面的写法1和写法2的区别是什么？答案：写法1是串行，写法2是并行，那到底是为什么呢？</p><p>参照之前的文章 <a href="https://daodaolee.cn/2021/01/30/%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%E3%80%90Promise%E7%AF%87%E3%80%91/">知其所以然【Promise篇】</a> 里面提到的，JS里面的主线程结束后，会把 任务队列 里的 微任务 拿到主线程中执行，而根据 <code> Promise</code> 的参数语法说明里：</p><blockquote><p>executor 是Promise 函数所传入的两个参数 (resolve 和 reject)，<code>Promise</code> 的实现会立即执行 executor，并传入 resolve 和 reject 函数 (Promise 构造器将会在返回新对象之前 executor )。</p></blockquote><p>这样的话表明 Promise 会立即执行回调函数，如果按照写法1，那么每个 await 都在等待上面的 await 执行完毕再执行自己，按照写法2，Promise先全部执行完毕了，然后全部放到了 微任务 里，等 await 调用，主线程直接执行 微任务 的单项就可以了。简单的说就是，可以立即执行的代码，不要放到 微任务 中等待慢慢执行，尤其是互相没有关系的代码块。</p><p>使用 <code>Promise.all</code> 也可以做到并行的效果：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> <span class="built_in">Promise</span>.all([getA(),getB()]);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p><em>这个东西我也想了半天，查了半天资料，最后查文档，才查出来 Promise 是会立即执行的，所以阅读文档还是很重要的！</em></p><p>参考资料：</p><ul><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">MDN-async函数</a></p></li><li><p><a href="http://www.ruanyifeng.com/blog/2015/05/async.html">async 函数的含义和用法</a></p></li><li><p><a href="https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9">6 Reasons Why JavaScript Async/Await Blows Promises Away (Tutorial)</a></p></li><li><p><a href="https://loveky.github.io/2017/04/09/translate-6-reasons-why-javascripts-async-await-blows-promises-away/">[译] 6个Async/Await完胜Promise的原因</a></p></li><li><p><a href="https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/">How to write async await without try-catch blocks in Javascript</a></p></li><li><p><a href="https://developers.google.com/web/fundamentals/primers/async-functions">异步函数 - 提高 Promise 的易用性</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前我们讲了 &lt;code&gt;Promise&lt;/code&gt; 的内部结构以及用法，这篇来说下另一个老生常谈的问题：&lt;code&gt;Async/Await&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Promise&lt;/code&gt; 出现之后，确实解决了很多异步执行方面的坑，可以说它在</summary>
      
    
    
    
    
    <category term="promise" scheme="https://daodaolee.cn/tags/promise/"/>
    
    <category term="异步" scheme="https://daodaolee.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="async" scheme="https://daodaolee.cn/tags/async/"/>
    
    <category term="await" scheme="https://daodaolee.cn/tags/await/"/>
    
  </entry>
  
  <entry>
    <title>一文讲解浏览器运行渲染机制、JS任务队列及事件循环</title>
    <link href="https://daodaolee.cn/2021/01/31/%E6%A2%B3%E7%90%86%E4%B8%80%E4%B8%8BJS%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>https://daodaolee.cn/2021/01/31/%E6%A2%B3%E7%90%86%E4%B8%80%E4%B8%8BJS%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2021-01-31T09:24:18.000Z</published>
    <updated>2021-01-31T13:34:18.055Z</updated>
    
    <content type="html"><![CDATA[<p>你是不是有过以下困难：</p><ul><li>多个方法互相嵌套，但是最终还是蒙对了</li><li>不是很明白为什么浏览器有时候会卡死</li><li>事件循环好像知道那么点，但是就是讲不出来为啥</li><li>……</li></ul><p>本篇文章就把你的问题给一一解答，当然这些东西想完弄清楚，肯定离不开<strong>进程</strong>，<strong>线程</strong>，<strong>浏览器内核</strong>，<strong>渲染</strong>，<strong>事件循环</strong>，任务队列等，我们就一个一个的来看，它们到底是怎么工作的。</p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>举个例子，一个工厂，它有自己独立的资源，工厂和工厂之间相互独立，各自做各自的事情。一个场子可以有很多工人，工人可以 单个作业 也可以 协同作业，工人做的事情，都只会在自己的工厂内，并且共享这个工厂的空间。</p><p>我们现在把概念放到进程上，一个进程就相当于一个工厂，工厂里的资源就相当于系统分配的独立内存，多个工厂各自做各自的事情就相当于进程之间相互独立，一个工厂有很多工人就相当于一个进程可以有很多线程，工人的作业就相当于线程完成任务，工人共享这个工厂的空间，就相当于一个进程下面的线程之间可以共享程序的内存。</p><p><img src="https://i.loli.net/2021/01/31/tONwQshzkDrBpZF.png" alt="进程和线程"></p><p>在 <strong>windows</strong> 的任务管理器中 CPU 和 内存 可以把每个进程的占用看的很清楚，当然 <strong>Mac OS</strong> 从活动监视器中也可以看到。所以：<strong>进程是 cpu 资源分配的最小单位，线程是cpu调度的最小单位</strong>。</p><p><img src="https://i.loli.net/2021/01/31/q85RksFWeVrxNfK.png" alt="macOS"></p><p><img src="https://i.loli.net/2021/01/31/jznfuqWstbFwl8E.png" alt="windows"></p><p><strong>大家所说的多线程和单线程，都是只在一个进程内的多和单！</strong></p><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p><em>前提：页面是跑在浏览器上的，也就是说浏览器是页面的载体，浏览器会制定一套规则，页面满足了这个规则然后才可以在到浏览器上正常运行。</em></p><p>浏览器本质上其实是一个软件，它运行在一个操作系统上(windows 或 MacOS 或 其他)，一般来说操作系统会开一个端口去运行这个软件，也就是为这个进程分配了CPU，内存 和 磁盘空间等。</p><p>那浏览器是单进程还是多进程呢？我们看一下：</p><p><img src="https://i.loli.net/2021/01/31/oi3gbNvJMl8sTaW.png" alt="进程"></p><p>可见它是个多个进程的浏览器！</p><p>在 Chrome 多进程架构里，它包括了四个进程：</p><ul><li>Browser进程（负责地址栏、书签栏、前进后退、网络请求、文件访问等）</li><li>Renderer进程（<strong>负责一个Tab内所有和网页渲染有关的所有事情，是最核心的进程</strong>）</li><li>GPU进程（负责GPU相关的任务）</li><li>Plugin进程（负责Chrome插件相关的任务）</li></ul><p>如果你打开它的任务管理器，你会发现：</p><p><img src="https://i.loli.net/2021/01/31/7vsm89SFdLMwTZk.png" alt="chrome的任务管理器"></p><p>上图我们可以看出：一个标签页就是一个进程，甚至一个扩展程序就是一个进程！在浏览器中打开一个网页就相当于新开了一个进程。</p><p><strong>但是：在这里浏览器有自己的优化机制，有时候打开多个标签页，进程会合并，所以每一个标签页对应一个进程不是绝对的。</strong></p><p>这样的多进程分配的好处是：</p><ul><li>如果一个页面挂了，不会影响其他页面，甚至影响到整个浏览器</li><li>避免安装的三方插件等影响了浏览器全局</li><li>多进程充分利用了多核的优势</li><li>把插件，扩展程序等全部隔离，提高稳定性</li></ul><p>当然，缺点很就明显了，内存消耗大，确实有点像空间换时间的意思。</p><h3 id="请求，响应"><a href="#请求，响应" class="headerlink" title="请求，响应"></a>请求，响应</h3><p>接下来我们看下浏览器是如何通过输入内容来请求成功的。</p><ol><li><p>当用户在地址栏输入内容时，UI线程首先问的是“这是搜索查询还是URL？”。在Chrome浏览器中，地址栏也是搜索输入字段，因此UI线程需要解析并决定是将您发送到搜索引擎还是请求的网站。</p><p><img src="https://i.loli.net/2021/01/31/YRkZwCcaKbHQJrf.png" alt="UI线程询问输入是搜索查询还是URL"></p></li><li><p>当用户按下Enter键时，UI线程会发起网络调用以获取网站内容。加载微调框显示在选项卡的角上，并且网络线程通过相应的协议（例如DNS查找和为请求建立TLS连接）。</p><p>此时，网络线程可能会收到服务器重定向标头，例如HTTP301。在这种情况下，网络线程与服务器正在请求重定向的UI线程进行通信。然后，将启动另一个URL请求。</p><p><img src="https://i.loli.net/2021/01/31/oThNMwPYd2tSniV.png" alt="UI线程与网络线程交谈以导航至mysite.com"></p></li><li><p>一旦有响应了，网络线程将在必要时查看流的前几个字节。响应的Content-Type标头应说明它是什么数据类型，但是由于可能丢失或错误， 因此在此处进行MIME Type检查。</p><p>如果响应是HTML文件，则下一步是将数据传递到渲染器进程，但是如果是zip文件或其他文件，则意味着这是下载请求，因此它们需要将数据传递到下载管理器。</p><p><img src="https://i.loli.net/2021/01/31/r6d4iczGNKPeXSg.png" alt="响应头包含Content-Type和有效载荷，有效载荷是实际数据"></p></li><li><p>网络线程从安全站点询问响应数据是否为HTML，并进行安全检查。</p><p><img src="https://i.loli.net/2021/01/31/QtOaw7foH4rMYnS.png" alt="网络线程从安全站点询问响应数据是否为HTML"></p><p>在这个时候，浏览器已经拿到响应了，接下来就开始进行渲染了。</p></li><li><p>一旦完成所有检查，并且Network线程确信浏览器应导航到请求的站点，则Network线程将告知UI线程数据已准备就绪。然后，UI线程找到一个渲染器进程来进行网页渲染。</p><p><img src="https://i.loli.net/2021/01/31/XE7mOI4DY5L8qP1.png" alt="网络线程告诉UI线程查找渲染器进程"></p></li><li><p>现在已经准备好数据和渲染器进程，将IPC从浏览器进程发送到渲染器进程以提交导航。它还会传递数据流，因此渲染器进程可以继续接收HTML数据。一旦浏览器进程听到确认已在渲染器进程中进行提交的确认，导航即完成，文档加载阶段开始。</p><p>此时，地址栏已更新，安全指示符和站点设置UI反映了新页面的站点信息。选项卡的会话历史记录将被更新，因此后退/前进按钮将逐步浏览刚刚导航到的站点。为了方便在关闭选项卡或窗口时恢复选项卡/会话，会话历史记录存储在磁盘上。</p><p><img src="https://i.loli.net/2021/01/31/vw3jBpUnIEf8Dxs.png" alt="浏览器和渲染器进程之间的IPC，请求渲染页面"></p></li></ol><p>   <img src="https://i.loli.net/2021/01/31/yCzPAlLBwdtOKEI.png" alt="从渲染器到浏览器的IPC进程通知页面已“加载”"></p><p>到这里为止，浏览器的请求和响应就完成了。那在响应之后如何渲染呢，我们接着往下看</p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>先说几个渲染进程内将要工作的线程：</p><ul><li>主线程(Main thread)：<strong>下载资源、执行js、计算样式、进行布局、绘制合成</strong></li><li>光栅线程（Raster thread）</li><li>合成线程（Compositor thread）</li><li>工作线程（Worker thread）</li></ul><p>在下面的渲染过程中，其实就是这四个进程的互相配合，我们一起来看下吧。</p><ol><li><p>当渲染过程接收提交消息用于导航和开始接收HTML数据，主线程开始解析文本串（HTML），使之成为一个 <code>Document Object Model</code> ，也就是 <strong>DOM</strong>。</p></li><li><p>网站有用到图片，CSS 和JavaScript的话，这些东西需要从网络或者缓存中加载，主线程可以边请求，边预加载构建DOM。</p><p><img src="https://i.loli.net/2021/01/31/iUmOeJc1daWs2Z9.png" alt="主线程解析HTML并构建DOM树"></p></li><li><p>当HTML解析器找到 <code>&lt;script&gt;</code> 标签后，将会暂停HTML解析，并且必须加载、解析和执行 JavaScript的代码。为什么？因为JavaScript 可以使用诸如 <code>document.write()</code> 更改整个DOM结构！所以开发人员在写代码的时候可以在 <code>&lt;script&gt;</code> 标签上加 <code>async</code> 或者 <code>defer</code> 属性。然后浏览器将会异步加载并运行JavaScript，不会阻止解析。</p></li><li><p>主线程解析CSS样式，并把CSS样式一一对应到DOM节点上，注意，此时CSS页面还没有生效，只是样式和节点绑定了关系。</p><p><img src="https://i.loli.net/2021/01/31/CYHbptVyWI3TwmS.png" alt="主线程解析CSS以添加计算样式"></p></li><li><p>接下来CSS根据DOM节点，会生成类似于DOM结构的一个布局树，仅包含了页面上可见内容的信息，如果有 <code>display: none</code> 等，则该元素不属于布局树。如果有<code>p::before &#123;content:&quot;123&quot;&#125;</code> 等伪类的存在，就算它不在DOM中，也会包含在布局树中。</p><p><img src="https://i.loli.net/2021/01/31/NwxgPsyOqojVh2p.png" alt="主线程遍历具有计算样式的DOM树并生成布局树"></p><p>在此绘制步骤中，主线程遍历布局树以创建绘制记录。绘画记录是绘画过程的注释，例如“先是背景，然后是文本，然后是矩形”，类似 <code>canvas</code>。</p><p>注意：在渲染的时候，每个步骤前面操作的结果都用于创建新数据，如果布局树发生了更改，文档受影响的部分就会重新绘制，也就是 <strong>重绘</strong>，开发过程中要尽量避免这一现象。</p></li><li><p>至此浏览器知道了：文档的结构，每个DOM元素的样式，页面的几何形状以及绘制的顺序。把这些东西换转为屏幕上像素我们称之为 <strong>光栅化</strong>。在现代浏览器中执行这一行为的过程，称为 **合成(Compositing)**，就是把页面各个部分分成若干层，分别进行栅格化，然后合成器线程的单独线程中进行合成，一个层可以称之为一个 layer。</p><p><img src="https://i.loli.net/2021/01/31/KkTc9AaRDru4iGQ.png" alt="主线程遍历布局树生成层树"></p></li><li><p>层分好了并确定了顺序之后，主线程就把这个信息提交给合成线程，然后合成器线程把每个图层栅格化，发送给栅格线程，栅格线程把它们存储在GPU内存内。</p><p><img src="https://i.loli.net/2021/01/31/GxOo9LUg2EY7HXi.png" alt="光栅线程创建图块的位图并发送到GPU"></p></li><li><p>最终，合成线程将栅格化的块合成帧，并通过IPC传递给浏览器进程，显示在屏幕上。</p><p><img src="https://i.loli.net/2021/01/31/E9xCQJ1vSYoGegl.png" alt="合成器线程创建合成框架。帧发送到浏览器进程，然后发送到GPU"></p></li></ol><p>至此，浏览器的请求，响应和渲染过程结束！</p><p>（一半了，稍微休息一下，我们再继续！）</p><h2 id="JS单线程"><a href="#JS单线程" class="headerlink" title="JS单线程"></a>JS单线程</h2><p>回顾一下，浏览器的渲染进程中，主线程里包括了执行JS，那也就意味着：</p><p><strong>JS在浏览器的 渲染进程(Rendered Process) 的 主线程(Main Thread) 内</strong>！</p><p><img src="https://i.loli.net/2021/01/31/6qvbFOlATQeai2U.png" alt="JS在主线程内"></p><p><strong>记住：JS是被设计成单线程的！</strong></p><blockquote><p>JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？     —— 阮一峰</p></blockquote><p>所以叙述出来就是：JS逻辑 和 UI渲染 是在一个线程中顺序发生的，二者同一时间只可以存在一个。继续回顾一下上面渲染所提到的，HTML解析器必须等待JS运行，JS是可以操作DOM 和 布局树的，会干扰到主线程在解析HTML的顺序，从而影响结果，所以为了页面的渲染统一，JS被设计成了 执行阻塞UI渲染型。</p><p>同时也反映出了一个问题：JS过多会造成页面卡顿，因为走不下去了。所以JS的逻辑一定不能冗余。</p><h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>既然JS是单线程，也就意味着里面的逻辑是排队运行的，后一个任务必须等前一个结束才可以运行。这样就会出一个问题，有没有一种可能是挂起不那么重要的任务，先走重要的，等结束之后再执行挂起的任务呢？</p><p>按照这个说法的话，所有任务就可以分成：<strong>同步任务(sync)</strong> 和 <strong>异步任务(async)</strong> ，同步任务就是主线程里面的排队进行，异步任务就是不进入主线程，进入一个 “任务队列(task queue)” 的地方呆着，看着主线程里的任务进行，一旦发现主线程的同步任务执行完了，就通知主线程，说我这里的异步任务可以执行了，该任务才会进入主线程执行。</p><p>所以有没有发现，那些鼠标点击事件，页面滚动，回调函数，http请求……其实就在任务队列里面。</p><h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环(Event Loop)"></a>事件循环(Event Loop)</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>有了任务队列的存在，就会有事件循环的存在，因为任务队列中可能有很多任务，一个在任务队列的任务进入到主线程后，任务队列依然会看着主线程，看看刚进去的这个有没有执行完毕，毕竟任务队列里还有很多没执行的任务，所以主线程去读取任务队列是循环不断的，也就叫做了 <strong>事件循环</strong>。</p><p>这里放张网图，基本上一看就明白了（参考自Philip Roberts的演讲《<a href="http://vimeo.com/96425312">Help, I’m stuck in an event-loop</a>》）</p><p><img src="https://i.loli.net/2021/01/31/DwyaGmCNZA5dgep.png" alt="事件循环"></p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>这个有点特殊，单独讲一下。</p><p>定时器不是个异步事件，是一个定时事件，但是仍属于一个回调操作，是被放在任务队列中的。</p><p>就算定时器被设置的时间是0，它也仍然会在主线程逻辑走完之后(此时栈清空了)，再执行，所以时间是0的定时器，它可以被理解为希望尽早的执行。</p><blockquote><p>需要注意的是，setTimeout()只是将事件插入了”任务队列”，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。要是当前代码耗时很长，有可能要等很久，所以并没有办法保证，回调函数一定会在setTimeout()指定的时间执行。     ——阮一峰</p></blockquote><h2 id="微任务-MicroTask-和宏任务-MacroTask"><a href="#微任务-MicroTask-和宏任务-MacroTask" class="headerlink" title="微任务(MicroTask)和宏任务(MacroTask)"></a>微任务(MicroTask)和宏任务(MacroTask)</h2><p>这段参考<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">Tasks, microtasks, queues and schedules</a>，一位谷歌开发者人员用实例讲述了任务执行顺序，并带有在线Demo，强烈建议过一遍(英语不好就逐句翻译)。</p><p>在JS中，主线程的任务叫 <code>宏任务(MacroTask)</code> ，宏任务执行完毕后，立即执行的任务叫 <code>微任务(MicroTask)</code> 。</p><p><strong>宏任务：</strong></p><ul><li>主线程已经存在了的任务叫宏任务，从任务队列中进入主线程的任务也叫宏任务，一个宏任务执行过程中，从头到尾不会执行其他的东西</li><li>浏览器会在一个宏任务结束后，在下一个宏任务开始前，对页面进行重新渲染</li></ul><p><strong>微任务：</strong></p><ul><li>当前宏任务执行结束后立即执行的任务叫微任务，也就是说它在前宏任务之后，后宏任务之前，渲染之前！</li><li>它的速度比定时器要快，因为不用等待渲染，定时器是宏任务</li><li>在一个宏任务执行结束后，所有的微任务都会执行完毕(渲染前)</li></ul><p>基于上面的概念，我们可以给常用的任务分下类：</p><ul><li>宏任务：主代码，setTimeout，setInterval，setImmediate，requestAnimationFrame，I/O，UI渲染</li><li>微任务：Promise，process.nextTick，MutationObserve，queueMicrotask</li></ul><p>当然 Vue 中的 nextTick 也就属于微任务了，最后放一张图帮助一下理解：</p><p><img src="https://i.loli.net/2021/01/31/ezIH3RLdm9C8OlS.png" alt="宏任务和微任务"></p><p>参考资料：</p><ul><li><p><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html#comment-text">JavaScript 运行机制详解：再谈Event Loop</a></p></li><li><p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops">Event Loops</a></p></li><li><p><a href="https://segmentfault.com/a/1190000022950333">浅谈浏览器架构、单线程js、事件循环、消息队列、宏任务和微任务</a></p></li><li><p><a href="https://segmentfault.com/a/1190000012925872">从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理</a></p></li><li><p><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part2">Inside look at modern web browser (part 2)</a></p></li><li><p><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part3">Inside look at modern web browser (part 3)</a></p></li><li><p><a href="https://html.spec.whatwg.org/multipage/parsing.html#overview-of-the-parsing-model">overview-of-the-parsing-model</a></p></li><li><p><a href="https://www.infoq.cn/article/CS9-WZQlNR5h05HHDo1b">史上最全！图解浏览器的工作原理</a></p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;你是不是有过以下困难：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;多个方法互相嵌套，但是最终还是蒙对了&lt;/li&gt;
&lt;li&gt;不是很明白为什么浏览器有时候会卡死&lt;/li&gt;
&lt;li&gt;事件循环好像知道那么点，但是就是讲不出来为啥&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本篇文章就把你的</summary>
      
    
    
    
    
    <category term="异步" scheme="https://daodaolee.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="JS" scheme="https://daodaolee.cn/tags/JS/"/>
    
    <category term="任务队列，事件循环" scheme="https://daodaolee.cn/tags/%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%EF%BC%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>知其所以然【Promise篇】</title>
    <link href="https://daodaolee.cn/2021/01/30/%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%E3%80%90Promise%E7%AF%87%E3%80%91/"/>
    <id>https://daodaolee.cn/2021/01/30/%E7%9F%A5%E5%85%B6%E6%89%80%E4%BB%A5%E7%84%B6%E3%80%90Promise%E7%AF%87%E3%80%91/</id>
    <published>2021-01-30T14:29:24.000Z</published>
    <updated>2021-01-30T14:47:45.158Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇讲了 <code>Promise </code> 的概念和简单用法之后，这篇来说下 Promise 内部结构和工作方式，看看它里面都藏了什么东西。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>上篇说道， <code>Promise</code>是一个函数返回的对象(用官话讲就是：一个在将来某个时刻产生一个单一结果的对象，代表了一个值，但是这个值不确定什么时候会被返回)，可以用来进行异步操作，可以拿到操作成功或者失败的结果。异步方法并不会返回最终的值，而是返回一个 Promise，这样才可以链式调用。</p><p>一个 <code>Promise</code> 有三种状态：</p><ol><li>待定(pending)：初始状态，也就是没有成功也没有失败，属于正在进行中</li><li>成功(fulfilled)：操作成功完成</li><li>拒绝(rejected)：操作失败</li></ol><p>待定状态下，要么通过一个值返回成功，要么报错被拒绝。当一个 Promise 在被绑定的时候就已经成功或者拒绝了，那么它就会被后面的逻辑调用，所以在完成异步操作和绑定处理方法之间不会存在竞争关系。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这种就是默认绑定了成功的状态</span></span><br><span class="line"><span class="built_in">Promise</span>.resolve().then()</span><br></pre></td></tr></table></figure><p>如果状态是操作成功或者失败，那么 Promise 就处于 已敲定状态(settled)，可以理解为结束的状态。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 这时，&quot;promise&quot; 已经被敲定了。</span></span><br><span class="line"><span class="keyword">const</span> x = promiseA.then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val,val+<span class="number">1</span>) );</span><br><span class="line"><span class="keyword">const</span> y = promiseA.then(<span class="function"><span class="params">val</span> =&gt;</span> <span class="built_in">console</span>.log(val,val+<span class="number">2</span>) );</span><br><span class="line"><span class="built_in">console</span>.log(x, y);</span><br><span class="line"><span class="comment">// x: 777 778</span></span><br><span class="line"><span class="comment">// y: 777 779</span></span><br></pre></td></tr></table></figure><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><p>在链式调用中，只有当第一个 Promise 执行完毕，从事件队列中移除，才会进行下一个。也就是说 Promise 里面的 return ，执行的是 Promise 被移除(弹出)，当前的返回值替换被弹出的 Promise 原来的位置，接着进行后面的异步操作。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li><p><code>Promise.resolve(value)</code></p><p>该方法返回一个value，如果值是 then，返回的 Promise 对象的最终状态由 then 方法决定，如果没有value，则返回 Promise 对象的状态为 <code>fulfilled</code> ，并且将该状态传到对应的 then 方法。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">123</span>);</span><br><span class="line"></span><br><span class="line">p1.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure></li><li><p><code>Promise.reject(reason)</code></p><p>该方法返回一个状态为失败的 Promise 对象，并将失败信息传递下去。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resolve = <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;resolved&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> reject = <span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;fail&#x27;</span>))</span><br><span class="line">  .then(resolve, reject)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Error: fail</span></span><br></pre></td></tr></table></figure></li><li><p><code>Promise.all(iterable)</code></p><p>该方法返回一个新的 Promise 对象，当 iterable 里的所有 Promise 都成功之后，才会触发成功。一旦有任何一个失败，就会立即出发该 Promise 对象失败。</p><p>成功：返回的值的顺序和调用的时候的排序一致。</p><p>失败：返回第一个触发失败的错误信息。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve(<span class="string">&quot;foo&quot;</span>), <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.all([p1, p2, p3]).then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// [3, &quot;123&quot;, &quot;foo&quot;]</span></span><br></pre></td></tr></table></figure><ul><li><p>如果传入的参数是空数组，就直接返回一个 已完成 状态的 Promise。</p></li><li><p>如果传入的的参数不包含任何 promise，就直接返回一个 已完成 状态的 Promise。</p></li><li><p>其他情况就会返回 pending 状态的 promise。这个返回的 <code>promise</code> 之后会在所有的 promise 都完成或者有一个失败时，异步地变为完成或者失败。</p></li></ul></li><li><p><code>Promise.allSettled(iterable)</code></p><p>等所有 Promise 状态都变成 <code>已敲定(settled)</code>，也就是每个 Promise 都变成成功状态或者已拒绝之后，返回一个 Promise，里面包含了每个 Promise的结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> <span class="built_in">setTimeout</span>(reject(<span class="string">&quot;foo&quot;</span>), <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.allSettled([p1, p2]).</span><br><span class="line">  then(<span class="function"><span class="params">results</span> =&gt;</span> <span class="built_in">console</span>.log(result));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* [&#123;</span></span><br><span class="line"><span class="comment">    status: &quot;fulfilled&quot;, value: 3</span></span><br><span class="line"><span class="comment">  &#125;,&#123;</span></span><br><span class="line"><span class="comment">  status: &quot;rejected&quot;, reason: &quot;foo&quot;</span></span><br><span class="line"><span class="comment">  &#125;]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p> 传入的参数得是一个数组，每个参数都是 <code>Promise</code>，每个结果都有一个 <code>status</code> 字符串，代表状态。</p></li><li><p><code>Promise.race(iterable)</code></p><p>当 iterable 参数里任意一个子 promise 成功或者失败，就结束。接着就会调用父promise后面绑定的相应逻辑，就会接着往下运行(只要一个有结果就会接着网后走)。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve(<span class="string">&quot;1&quot;</span>, <span class="number">5000</span>))</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(resolve(<span class="string">&quot;2&quot;</span>, <span class="number">1000</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race([p1, p2]).then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>通过 <code>Promise.prototype</code> ，可以看到它的原型链上有个三个方法：</p><ol><li><p><code>Promise.prototype.then(onFulfilled, onRejected)</code></p><p>给当前的 Promise 添加 解决 和 拒绝 回调，并返回一个 Promise，所以可以进行链式调用。</p></li><li><p><code>Promise.prototype.catch(onRejected)</code></p><p>给当前的 Promise 设置为 拒绝状态 ，并返回一个 Promise。</p><p>该方法其实就是 <code>.then(null, rejection)</code> ，或者 <code>.then(undefined, rejection)</code>的别名。如果有多个 catch，那么当前 catch 捕获的是上一个报错。</p></li><li><p><code>Promise.prototype.finally(onFinally)</code></p><p>给当前的 Promise 添加一个回调的事件处理，在 Promise 解析完毕后，返回一个 新的Promise对象。无论状态是成功或者失败，该回调都会在当前promise运行结束后调用，</p></li></ol><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>知道了 <code>Promise</code> 的内部结构之后，我们来简单的实现一个 Promise（实现的细节要与规范符合）。</p><p><code>myPromis </code> 实现思路：</p><ol><li>Promise 是 new 出来的，而且需要一个 executor 执行器</li><li>executor 带入 resolve 和 reject</li><li>状态只能从 pending 到 fulfilled 或者 rejected</li><li>状态一旦确认不可改变</li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myPromise</span>(<span class="params">executor</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  _this.status = <span class="string">&quot;pending&quot;</span>; <span class="comment">//状态</span></span><br><span class="line">  _this.onFulfilled = []; <span class="comment">//成功回调</span></span><br><span class="line">  _this.onRejected = []; <span class="comment">//失败回调</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//定义resolve  </span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_this.status === <span class="string">&quot;pending&quot;</span>)&#123;</span><br><span class="line">      _this.status = <span class="string">&quot;fulfilled&quot;</span>;</span><br><span class="line">      _this.value = value;</span><br><span class="line">      _this.onFulfilled.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//定义reject</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_this.status === <span class="string">&quot;pending&quot;</span>)&#123;</span><br><span class="line">      _this.status === <span class="string">&quot;rejected&quot;</span>;</span><br><span class="line">      _this.reason = reason;</span><br><span class="line">      _this.onRejected.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> fn());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//调用  </span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executor(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此呢，通过一个 <code>myPromise</code> 就初始化好了，里面包括了状态，值和两个回调。接下来我们去构造 <code>then</code> 方法。</p><ol><li>then 方法有两个参数，分别是 myPromise 的两个回调(onFulfilled 和 onRejected)</li><li>then 方法是在 myPromise 状态结束之后调用的：<ol><li>成功：执行 onFulfilled，把值传进去</li><li>失败：执行onRejected，把错误原因传进去</li><li>待定：等状态确定后再执行成功或者失败，所以要先把成功和失败的回调存起来</li></ol></li><li>then 方法可以链式调用，每次调用都返回一个 promise</li><li>then的结果<ol><li>如果是一个结果，就传递给下一个 then 的成功回调(onFulfilled)</li><li>如果是一个异常，就传递给下一个 then 的失败回调(onRejected)</li><li>如果返回的是一个 promise，就得等待这个 promise，执行完之后，成功就走下一个 then 的成功，否则就走下一个 then 的失败</li></ol></li></ol><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">myPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">onFulfilled, onRejected</span>)</span>&#123;</span><br><span class="line">  onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">&quot;function&quot;</span> ? onFulfilled : <span class="function"><span class="params">value</span> =&gt;</span> value;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&quot;function&quot;</span> ? onRejected : <span class="function"><span class="params">reason</span> =&gt;</span> &#123; <span class="keyword">throw</span> reason&#125;;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line"> <span class="keyword">let</span> promiseThen = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">   <span class="comment">// 返回的状态是成功，一个结果</span></span><br><span class="line">   <span class="keyword">let</span> fulfilledFn = </span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> fn = onFulfilled(_this.value);</span><br><span class="line">         resolvePromise(promiseThen, fn, resolve, reject);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">         reject(e);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;,<span class="number">0</span>);</span><br><span class="line">   <span class="comment">// 返回的状态是失败，一个异常</span></span><br><span class="line">   <span class="keyword">let</span> rejectedFn = </span><br><span class="line">     <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">let</span> fn = onRejected(_this.reason);</span><br><span class="line">         resolvePromise(promiseThen, fn, resolve, reject);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">         reject(e);</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">switch</span>(_this.status)&#123;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;fulfilled&quot;</span>:</span><br><span class="line">       &#123;</span><br><span class="line">         fulfilledFn();</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;rejected&quot;</span>:</span><br><span class="line">       &#123;</span><br><span class="line">         rejectedFn();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">     <span class="keyword">case</span> <span class="string">&quot;pending&quot;</span>:</span><br><span class="line">       &#123;</span><br><span class="line">         _this.onFulfilled.push(fulfilledFn);</span><br><span class="line">         _this.onRejected.push(rejectedFn);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promiseThen, fn, resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">  <span class="keyword">if</span>(promiseThen === fn)&#123;</span><br><span class="line">    reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle&#x27;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(fn &amp;&amp; <span class="keyword">typeof</span> fn === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> fn === <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> used; <span class="comment">//PromiseA+2.3.3.3.3 只能调用一次</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> then = fn.then;</span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">typeof</span> then === <span class="string">&quot;function&quot;</span>)&#123;</span><br><span class="line">        then.call(fn, <span class="function"><span class="params">y</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(used) <span class="keyword">return</span>;</span><br><span class="line">          used = <span class="literal">true</span>;</span><br><span class="line">          resolvePromise(promiseThen, y, resolve, reject);</span><br><span class="line">        &#125;, <span class="function"><span class="params">r</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span>(used) <span class="keyword">return</span>;</span><br><span class="line">          used = <span class="literal">true</span>;</span><br><span class="line">          reject(r);</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(used) <span class="keyword">return</span>;</span><br><span class="line">        used = <span class="literal">true</span>;</span><br><span class="line">        resolve(fn);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span>(used) <span class="keyword">return</span>;</span><br><span class="line">      used = <span class="literal">true</span>;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    resolve(fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有关其他的方法实现，可以查看<a href="https://github.com/YvetteLau/Blog/issues/2">Promise的源码实现（完美符合Promise/A+规范）</a>。</p><p>至此 <code>Promise </code> 的用法就结束了，实际项目运用中会配合<strong>事件循环机制</strong>一起使用，后文再叙。</p><p>参考资料：</p><ul><li><a href="https://promisesaplus.com/">Promises/A+</a></li><li><a href="https://github.com/YvetteLau/Blog/issues/2">Promise的源码实现（完美符合Promise/A+规范）</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;上一篇讲了 &lt;code&gt;Promise &lt;/code&gt; 的概念和简单用法之后，这篇来说下 Promise 内部结构和工作方式，看看它里面都藏了什么东西。&lt;/p&gt;
&lt;h2 id=&quot;结构&quot;&gt;&lt;a href=&quot;#结构&quot; class=&quot;headerlink&quot; title=&quot;结构&quot;&gt;</summary>
      
    
    
    
    
    <category term="promise" scheme="https://daodaolee.cn/tags/promise/"/>
    
    <category term="异步" scheme="https://daodaolee.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>知其然【Promise篇】</title>
    <link href="https://daodaolee.cn/2021/01/30/%E7%9F%A5%E5%85%B6%E7%84%B6%E3%80%90Promise%E7%AF%87%E3%80%91/"/>
    <id>https://daodaolee.cn/2021/01/30/%E7%9F%A5%E5%85%B6%E7%84%B6%E3%80%90Promise%E7%AF%87%E3%80%91/</id>
    <published>2021-01-30T14:28:15.000Z</published>
    <updated>2021-01-30T14:45:36.392Z</updated>
    
    <content type="html"><![CDATA[<p>要想掌握 <code>Promise</code>，先从概念和使用方法入手，而后刨根它的原理，方可大成。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p> 抛去所有和它有关的东西，<code>Promise</code> 这个词，翻译过来是 <strong>承诺</strong> 的意思，那么我们可以猜想，它是不是一个有关逻辑状态的东西呢。</p><p><strong><code>Promise</code> 是一个对象</strong>，它代表了一个异步操作的 <strong>完成</strong> 或者 <strong>失败</strong>，本质上它是一个函数返回的对象，我们可以在他上面绑定回调函数，这样就不需要在一开始把回调函数作为参数传入这个函数了。</p><p>意思是说：</p><ol><li>首先我们认定了 <code>Promise</code>是一个函数</li><li>它是一个返回了管理异步操作状态(成功 / 失败)的函数</li><li>它默认绑定了回调函数</li><li>它的返回值是一个对象</li></ol><p>那我们可以尝试着写一个 <strong>伪Promise</strong></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">params</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> successCallback = <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> failedCallback = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> error</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> &#123;params, successCallback, failedCallback&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. 可以这样调用</span></span><br><span class="line"><span class="keyword">const</span> promise = fn(params);</span><br><span class="line">promise.then(successCallback, failedCallback);</span><br><span class="line"><span class="comment">// 2. 也可以这样调用</span></span><br><span class="line">fn(params).then(successCallback, failedCallback);</span><br></pre></td></tr></table></figure><p>我们把这称为 <em>异步函数调用</em> ，在使用 <code>Promise</code> 的时候，会有以下约定：</p><ol><li>在本轮事件循环运行完成之前，回调函数是不会被调用的</li><li>即使异步操作结束，在这之后通过 <code>then()</code> 添加的回调函数也会被执行</li><li>通过 <code>then()</code> 可以添加多个回调函数，它们按照插入的顺序依次执行</li></ol><p>所以：<code>Promise</code> 很棒的一点就是 <strong>链式调用</strong>，下面我们通过链式调用简单使用一下。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p>我们先模拟一个环境：连续执行多个异步操作，上个操作结束后，才开始下一个，并带上上一个的返回值。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以这样写</span></span><br><span class="line"><span class="keyword">const</span> promise1 = fn();</span><br><span class="line"><span class="keyword">const</span> promise2 = promise.then(successCB, failedCB);</span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以这样写</span></span><br><span class="line"><span class="keyword">const</span> promise2 = fn().then(successCB, failedCB);</span><br></pre></td></tr></table></figure><p>在上面的例子里， <code>Promise2</code> 表示 <code>fn</code>() 函数的完成，也表示了传入的<code> successCB()</code> 或者 <code>failedCB()</code> 的完成，当然这两个函数也返回了一个 Promise 对象，从而形成一个异步操作。</p><p>此刻我们就解决了 <em>回调地域</em> 的问题：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  fn1(result, <span class="function"><span class="params">newResult</span> =&gt;</span> &#123;</span><br><span class="line">    fn2(newResult, <span class="function"><span class="params">finalResult</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">//do something...</span></span><br><span class="line">    &#125;, failedCB)</span><br><span class="line">  &#125;, failedCB)</span><br><span class="line">&#125;, failedCB)</span><br></pre></td></tr></table></figure><p>上面的回调地域，我们把回调绑定到 Promise 上，形成一个 Promise 链，再看：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn().then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fn1(result);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">newResult</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fn2(newResult);</span><br><span class="line">&#125;).then(<span class="function"><span class="params">finalResult</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//do something...</span></span><br><span class="line">&#125;).catch(failedCB)</span><br><span class="line"></span><br><span class="line"><span class="comment">//上方的catch(failedCB) 就是 then(null, failedCB)的缩写</span></span><br></pre></td></tr></table></figure><p>看起来清爽了很多🎉。</p><p>那么在这个时候考虑一个问题，如果在一个链式操作中，使用了一个 <code>catch()</code>，再次继续回调怎么办？</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;初始化&#x27;</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;有哪里不对了&#x27;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行「这个」&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行「那个」&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;执行「这个」，无论前面发生了什么&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="comment">// 执行“那个”</span></span><br><span class="line"><span class="comment">// 执行“这个”，无论前面发生了什么</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：因为抛出了错误 <em>有哪里不对了</em>，所以前一个 <em>执行「这个」</em> 没有被输出。</p><h2 id="时序问题"><a href="#时序问题" class="headerlink" title="时序问题"></a>时序问题</h2><p>在理想状态下，所有的异步函数其实都已经返回了 Promise 了，但是还是有些特殊的回调比如定时器，如果混用 Promise 和 定时器 可能会造成时序问题，所以，最好的做法是把有问题的函数封装，永远不要直接调用它们：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> wait = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms));</span><br><span class="line"></span><br><span class="line">wait(<span class="number">1000</span>).then(<span class="function">()=&gt;</span>&#123;fn()&#125;)</span><br></pre></td></tr></table></figure><p><code>then()</code> 方法的函数会被放到一个微任务队列中，而不是立即执行，这意味着它是在JS事件队列的所有运行时结束了，并且事件队列被清空了之后，才开始执行的。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve().then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">2</span>)).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>); <span class="comment">// 1, 2, 3, 4</span></span><br></pre></td></tr></table></figure><p><em>后期会补一篇循环机制的文章，专门讲下事件队列</em>。</p><h2 id="并行"><a href="#并行" class="headerlink" title="并行"></a>并行</h2><p>平常用的比较多的就是 <code>Promise.all()</code> 和 <code>Promise.race()</code> 了，它们两个是并行运行异步的方法，也就是都执行完之后才可以操作结果，但是坏处就是只要有一个失败，就会中断并抛出异常。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([fn1(), fn2()])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// [result1,result2]</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//返回最先被reject失败的状态</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Promise.race()</code> 与 <code>Promise.all() </code> 不一样的地方就是，按走完的时间顺序排序结果。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([fn1(), fn2()])</span><br><span class="line">.then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// [result2, result1] or [result1, result2]</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>注意：一定要在 <code>then()</code> 方法里返回一个 Promise 对象(总是返回或终止 Promise)，这样才是一条完整的可异步执行的链。</strong></p><p>上面简单的把 <code>Promise</code> 的概念和简单使用阐述了一下，主要针对的是对 promise 不熟悉的朋友，也算是一个简单的回顾。“知其所以然【Promise篇】“ 会把里面的细节讲一下。</p><p>参考资料：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_promises">使用Promise</a></li><li><a href="https://www.cnblogs.com/lvdabao/p/es6-promise-1.html">大白话讲解Promise（一）</a></li><li><a href="https://zhuanlan.zhihu.com/p/24684803">这是一篇傻瓜都能看懂的Promises文章！</a></li><li><a href="https://wiki.jikexueyuan.com/project/javascript-promise-mini-book/what-is-the-promise.html">什么是Promise</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;要想掌握 &lt;code&gt;Promise&lt;/code&gt;，先从概念和使用方法入手，而后刨根它的原理，方可大成。&lt;/p&gt;
&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt; 抛去所有和它有关的</summary>
      
    
    
    
    
    <category term="promise" scheme="https://daodaolee.cn/tags/promise/"/>
    
    <category term="异步" scheme="https://daodaolee.cn/tags/%E5%BC%82%E6%AD%A5/"/>
    
  </entry>
  
  <entry>
    <title>重装Mac历程</title>
    <link href="https://daodaolee.cn/2021/01/22/%E9%87%8D%E8%A3%85Mac%E5%8E%86%E7%A8%8B/"/>
    <id>https://daodaolee.cn/2021/01/22/%E9%87%8D%E8%A3%85Mac%E5%8E%86%E7%A8%8B/</id>
    <published>2021-01-22T08:08:13.000Z</published>
    <updated>2021-01-25T09:03:04.939Z</updated>
    
    <content type="html"><![CDATA[<p>自从升级了 <code>Big Sur</code> 之后，本以为 Mac变为 iPad 会更轻便更舒服，然而，平常工作状态下，cpu直飙60%左右，转速也基本在2000，用Node打个包，转速能到5000，真的简直了。常用软件虽然也慢慢的都适配了 Big Sur，但是总感觉有点不舒服（iPreview直接向下不兼容了……淦，不知道其他有没有）。于是乎在工作稳定和体验新系统的权衡之下，还是妥妥的降级到了 <code>mojave</code>。还是熟悉的配方，还是熟悉的味道，还是熟悉的百分之十以下的cpu，还是熟悉的一千多转速，哪里都很香。</p><p>因为只熟悉 <code>windows</code> 的系统，<code>Mac</code> 的话，自己还没有搞过系统，以前有过一次还是从淘宝上花钱让别人远程装了的……网上找了一堆资料，最终总结出比较踏实的重装流程，然后就开始了：</p><ol><li><p>下载系统⬇</p><p>到  <code>App Store </code> 下载相应的系统，如果在 <code>App Store</code> 里面找不到，那就去官网下载（<a href="https://apps.apple.com/cn/app/macos-big-sur/id1526878132?ls=1&mt=12">Big Sur系统链接</a>，<a href="https://apps.apple.com/cn/app/macos-catalina/id1466841314?ls=1&mt=12">Catalina系统链接</a>，<a href="https://apps.apple.com/cn/app/macos-mojave/id1398502828?ls=1&mt=12">Mojave系统链接</a>，<a href="https://apps.apple.com/cn/app/macos-high-sierra/id1246284741?ls=1&mt=12">High Sierra系统链接</a>），因为有可能商店里只有最新的系统。</p><p>下载好之后可以在 <code>Launchpad</code>界面看到一个安装程序。如果是要升级系统，直接点击就可以了，如果要降级，别点，留着。</p></li><li><p>做系统盘💿</p><p>接下来就是格式化U盘，去磁盘工具里，抹掉U盘，名称先改成 <code>MyVolume</code> ，格式为 <code>Mac OS扩展 (日志式)</code>。抹完之后就开始制作系统盘了。</p><p>根据想做的系统盘，在终端里输入以下命令（注意命令里的 <code>MyVolume</code>就是上面系统盘的名称）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Catalina (10.15)</span></span><br><span class="line">sudo /Applications/Install\ macOS\ Catalina.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mojave (10.14)</span></span><br><span class="line">sudo /Applications/Install\ macOS\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</span><br><span class="line"></span><br><span class="line"><span class="comment"># High Sierra (10.13)</span></span><br><span class="line">sudo /Applications/Install\ macOS\ High\ Sierra.app/Contents/Resources/createinstallmedia --volume /Volumes/MyVolume</span><br></pre></td></tr></table></figure><p>然后会输入密码，输入之后回车，接着输入 <code>y</code> ，再回车就可以看到安装的进度条了，大概3~5分钟。</p><p>提示<code>  Done</code> 之后，就制作完成了。</p></li><li><p>安装✌</p><p>电脑关机，一直按住 <code>⌥alt</code>键( 也就是option )，然后开机，开机也要一直按住 <code>⌥alt</code> ，界面会出来一个磁盘和一个安装系统的图标。进去右边，选择磁盘工具，左侧选择“Macintosh HD”( 注意看清楚是“内置”栏下面的，不要选“磁盘映像”栏下面的 )，格式默认选择 <code>APFS</code> ，没有的话就选择 <code>Mac OS 扩展( 日志式 )</code>。抹完之后，点击关闭，回到之前的界面，选择 <code>安装macOS</code>。</p><p>本以为到这里就可以结束了，然而我的电脑报错了！</p><p><img src="https://i.loli.net/2021/01/25/kXiYCrSh6IRs4qj.jpg"></p><p>本来有点惊讶，还以为哪里出错了，看完这个提示之后感觉应该不是问题，就按着上面的接着操作了，重新启动后，菜单栏有个安全性实用工具，把 <code>外部启动</code> 修改为 <code>允许从外部介质启动</code> 就可以了，有点像BIOS更改启动项的味道。接下来一切顺利，重装之后是真干净，什么都没有，Xcode，Java全部干掉了，然而还是硬着头皮装回来一部分。</p><p>整个过程还是比较顺利的，有想降级的朋友可以试着降级，不必担心什么，只要东西备份好就可以了，我有内测阿里云盘的权限之后，把东西都放上去了。速度还可以，不太舒服的地方就是下载的时候不能下载文件夹，只能下载文件，有点头疼。</p><p>over~👨‍💻</p></li></ol><p>参考资料:</p><ul><li><a href="https://zhuanlan.zhihu.com/p/39103887">macOS 重装系统 Mojave Catalina Big Sur 升级 降级mac OS</a></li><li><a href="https://www.zhihu.com/question/21454213">macOS 系统如何重装？</a></li><li><a href="https://support.apple.com/zh-cn/HT204904">如何重新安装 macOS</a></li><li><a href="https://support.apple.com/zh-cn/HT208198">关于“启动安全性实用工具”</a></li><li><a href="https://discussionschinese.apple.com/thread/250455252">重装系统安装关键性更新失败</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;自从升级了 &lt;code&gt;Big Sur&lt;/code&gt; 之后，本以为 Mac变为 iPad 会更轻便更舒服，然而，平常工作状态下，cpu直飙60%左右，转速也基本在2000，用Node打个包，转速能到5000，真的简直了。常用软件虽然也慢慢的都适配了 Big Sur，但是总感</summary>
      
    
    
    
    
    <category term="Mac" scheme="https://daodaolee.cn/tags/Mac/"/>
    
  </entry>
  
  <entry>
    <title>http的option请求</title>
    <link href="https://daodaolee.cn/2019/06/24/http%E7%9A%84option%E8%AF%B7%E6%B1%82/"/>
    <id>https://daodaolee.cn/2019/06/24/http%E7%9A%84option%E8%AF%B7%E6%B1%82/</id>
    <published>2019-06-24T10:50:08.000Z</published>
    <updated>2021-01-25T07:54:09.324Z</updated>
    
    <content type="html"><![CDATA[<p>先看两张图：</p><p><img src="https://i.loli.net/2019/06/20/5d0b73254660812409.png"></p><p><img src="https://i.loli.net/2019/06/20/5d0b732a2829499623.png"></p><p>流程是这样：选择支付方式，填入充值金额，跳转到“选择银行卡界面”，但是在跳转的过程中走了2次<code>get_card</code>请求。</p><p>由于模块是H5纯静态页面，肯定会遇到跨域的问题，之前是用<code>jsonp</code>解决的，但是现在需要给后端传一堆<code>headers</code> 头部信息，然后，jsonp就不行了，因为他的实质是src标签，然后用callback传的，而且只能传get，所以这次接口的改动，只能让后端配置CORS了，也就是<code>Allow-Control-Allow-Origin: *</code> 和<code>Allow-Control-Allow-Methods:GET,POST</code> 让后端配置这个就可以了，再保险点，把<code>*</code> 变成<code>访问地址</code> ，然后就出现了上面的情况，第一次的<code>Request Method:OPTION</code> ，而且没有发送请求头，第二次就是 正常的post了。</p><p>出现第一次的原因是探测请求，客户端可以在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能。</p><blockquote><p>在ajax中出现options请求，也是一种提前探测的情况，ajax跨域请求时，如果请求的是json，就属于复杂请求，因此需要提前发出一次options请求，用以检查请求是否是可靠安全的，如果options获得的回应是拒绝性质的，比如404\403\500等http状态，就会停止post、put等请求的发出。</p></blockquote><p>如果你查资料(W3C规范)，你会发现在跨域请求中，分为简单请求（get和部分post，post时content-type属于application/x-www-form-urlencoded，multipart/form-data，text/plain中的一种）和复杂请求。而复杂请求发出之前，就会出现一次options请求。</p><p>参考资料：</p><p><a href="http://www.tangshuang.net/2271.html">jquery ajax 请求中多出现一次OPTIONS请求及其解决办法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;先看两张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/20/5d0b73254660812409.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/06/20/5d0b732a282</summary>
      
    
    
    
    <category term="FE" scheme="https://daodaolee.cn/categories/FE/"/>
    
    <category term="http" scheme="https://daodaolee.cn/categories/FE/http/"/>
    
    
    <category term="http" scheme="https://daodaolee.cn/tags/http/"/>
    
    <category term="option" scheme="https://daodaolee.cn/tags/option/"/>
    
  </entry>
  
  <entry>
    <title>form表单提交的submit和ajax区别</title>
    <link href="https://daodaolee.cn/2019/01/23/form%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E7%9A%84submit%E5%92%8Cajax%E5%8C%BA%E5%88%AB/"/>
    <id>https://daodaolee.cn/2019/01/23/form%E8%A1%A8%E5%8D%95%E6%8F%90%E4%BA%A4%E7%9A%84submit%E5%92%8Cajax%E5%8C%BA%E5%88%AB/</id>
    <published>2019-01-23T13:05:22.000Z</published>
    <updated>2021-01-25T07:54:07.450Z</updated>
    
    <content type="html"><![CDATA[<h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><ul><li>submit：更新数据完成后，需要<strong>转到一个空白的页面</strong>再对原页面进行提交后的处理，即重绘。</li><li>ajax：异步进行，直接返回原页面进行提交后的处理，比submit少增加一个页面，即局部刷新。</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><ul><li>ajax：出于安全性的考虑，不能对文件进行操作，所以不可以通过ajax来实现文件上传</li><li>submit：通过隐藏form的submit可以实现文件上传</li></ul><h2 id="form默认提交"><a href="#form默认提交" class="headerlink" title="form默认提交"></a>form默认提交</h2><p>如果想要submit后<strong>不刷新页面</strong>，在该方法的最后加上 <code>return false</code> ，就可以了。</p><p><em><code>return false</code> 的含义不是阻止事件继续向顶层元素传播，而是阻止浏览器对事件的默认处理方式。在js中，它的作用一般是用来取消默认动作的。</em></p><p><em><code>return false</code> 等效于 <code>window.event.returnValue = false</code></em> 。</p><blockquote><p>因为原页面用 form 提交到另一个域名之后，原页面的脚本无法获取新页面中的内容。所以浏览器认为这是安全的。而 AJAX 是可以读取响应内容的，因此浏览器不能允许你这样做。 如果你细心的话你会发现，其实请求已经发送出去了，你只是拿不到响应而已。 所以浏览器这个策略的本质是，一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容。但浏览器并不阻止你向另一个域名发送请求。 ——来自知乎</p></blockquote><p>有关同源策略和跨域，可以参考 <a href="https://mp.weixin.qq.com/s?__biz=MzU0OTExNzYwNg==&mid=2247483685&idx=1&sn=543e9736146405e9e5b37ec5a1c4b448">跨域的那些事儿</a></p><p>参考资料：</p><p><a href="https://www.cnblogs.com/zhujiabin/p/4901167.html">Ajax提交与传统Form表单提交的区别说明</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;页面&quot;&gt;&lt;a href=&quot;#页面&quot; class=&quot;headerlink&quot; title=&quot;页面&quot;&gt;&lt;/a&gt;页面&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;submit：更新数据完成后，需要&lt;strong&gt;转到一个空白的页面&lt;/strong&gt;再对原页面进行提交后的处理，即重绘。&lt;/l</summary>
      
    
    
    
    <category term="FE" scheme="https://daodaolee.cn/categories/FE/"/>
    
    <category term="form" scheme="https://daodaolee.cn/categories/FE/form/"/>
    
    
    <category term="form" scheme="https://daodaolee.cn/tags/form/"/>
    
    <category term="ajax" scheme="https://daodaolee.cn/tags/ajax/"/>
    
  </entry>
  
</feed>
